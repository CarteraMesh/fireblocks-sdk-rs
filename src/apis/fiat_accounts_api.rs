/*
 * Fireblocks API
 *
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.8.0
 * Contact: developers@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait FiatAccountsApi: Send + Sync {
    async fn deposit_funds_from_linked_dda(&self,  params: DepositFundsFromLinkedDdaParams ) -> Result<models::DepositFundsFromLinkedDdaResponse, Error<DepositFundsFromLinkedDdaError>>;
    async fn get_fiat_account(&self,  params: GetFiatAccountParams ) -> Result<models::FiatAccount, Error<GetFiatAccountError>>;
    async fn get_fiat_accounts(&self, ) -> Result<Vec<models::FiatAccount>, Error<GetFiatAccountsError>>;
    async fn redeem_funds_to_linked_dda(&self,  params: RedeemFundsToLinkedDdaParams ) -> Result<models::RedeemFundsToLinkedDdaResponse, Error<RedeemFundsToLinkedDdaError>>;
}

pub struct FiatAccountsApiClient {
    configuration: Arc<configuration::Configuration>
}

impl FiatAccountsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`deposit_funds_from_linked_dda`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DepositFundsFromLinkedDdaParams {
    /// The ID of the fiat account to use
    pub account_id: String,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>,
    pub funds: Option<models::Funds>
}

/// struct for passing parameters to the method [`get_fiat_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetFiatAccountParams {
    /// The ID of the fiat account to return
    pub account_id: String
}

/// struct for passing parameters to the method [`redeem_funds_to_linked_dda`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RedeemFundsToLinkedDdaParams {
    /// The ID of the fiat account to use
    pub account_id: String,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>,
    pub funds: Option<models::Funds>
}


#[async_trait]
impl FiatAccountsApi for FiatAccountsApiClient {
    /// Deposits funds from the linked DDA.
    async fn deposit_funds_from_linked_dda(&self,  params: DepositFundsFromLinkedDdaParams ) -> Result<models::DepositFundsFromLinkedDdaResponse, Error<DepositFundsFromLinkedDdaError>> {
        
        let DepositFundsFromLinkedDdaParams {
            account_id,
            idempotency_key,
            funds,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/fiat_accounts/{accountId}/deposit_from_linked_dda", local_var_configuration.base_path, accountId=crate::apis::urlencode(account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&funds);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<DepositFundsFromLinkedDdaError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a fiat account by ID.
    async fn get_fiat_account(&self,  params: GetFiatAccountParams ) -> Result<models::FiatAccount, Error<GetFiatAccountError>> {
        
        let GetFiatAccountParams {
            account_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/fiat_accounts/{accountId}", local_var_configuration.base_path, accountId=crate::apis::urlencode(account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetFiatAccountError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all fiat accounts.
    async fn get_fiat_accounts(&self, ) -> Result<Vec<models::FiatAccount>, Error<GetFiatAccountsError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/fiat_accounts", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetFiatAccountsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Redeems funds to the linked DDA.
    async fn redeem_funds_to_linked_dda(&self,  params: RedeemFundsToLinkedDdaParams ) -> Result<models::RedeemFundsToLinkedDdaResponse, Error<RedeemFundsToLinkedDdaError>> {
        
        let RedeemFundsToLinkedDdaParams {
            account_id,
            idempotency_key,
            funds,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/fiat_accounts/{accountId}/redeem_to_linked_dda", local_var_configuration.base_path, accountId=crate::apis::urlencode(account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&funds);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<RedeemFundsToLinkedDdaError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`deposit_funds_from_linked_dda`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DepositFundsFromLinkedDdaError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_fiat_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFiatAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_fiat_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFiatAccountsError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redeem_funds_to_linked_dda`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedeemFundsToLinkedDdaError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

