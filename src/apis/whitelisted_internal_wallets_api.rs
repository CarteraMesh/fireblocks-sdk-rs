// Fireblocks API
//
// Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com)
//
// The version of the OpenAPI document: 1.8.0
// Contact: developers@fireblocks.com
// Generated by: https://openapi-generator.tech

use {
    super::{configuration, Error},
    crate::{apis::ResponseContent, models},
    async_trait::async_trait,
    reqwest,
    serde::{Deserialize, Serialize},
    std::sync::Arc,
};

#[async_trait]
pub trait WhitelistedInternalWalletsApi: Send + Sync {
    async fn create_internal_wallet(
        &self,
        params: CreateInternalWalletParams,
    ) -> Result<models::UnmanagedWallet, Error<CreateInternalWalletError>>;
    async fn create_internal_wallet_asset(
        &self,
        params: CreateInternalWalletAssetParams,
    ) -> Result<models::WalletAsset, Error<CreateInternalWalletAssetError>>;
    async fn delete_internal_wallet(
        &self,
        params: DeleteInternalWalletParams,
    ) -> Result<(), Error<DeleteInternalWalletError>>;
    async fn delete_internal_wallet_asset(
        &self,
        params: DeleteInternalWalletAssetParams,
    ) -> Result<(), Error<DeleteInternalWalletAssetError>>;
    async fn get_internal_wallet(
        &self,
        params: GetInternalWalletParams,
    ) -> Result<models::UnmanagedWallet, Error<GetInternalWalletError>>;
    async fn get_internal_wallet_asset(
        &self,
        params: GetInternalWalletAssetParams,
    ) -> Result<models::WalletAsset, Error<GetInternalWalletAssetError>>;
    async fn get_internal_wallets(
        &self,
    ) -> Result<Vec<models::UnmanagedWallet>, Error<GetInternalWalletsError>>;
    async fn set_customer_ref_id_for_internal_wallet(
        &self,
        params: SetCustomerRefIdForInternalWalletParams,
    ) -> Result<(), Error<SetCustomerRefIdForInternalWalletError>>;
}

pub struct WhitelistedInternalWalletsApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl WhitelistedInternalWalletsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

/// struct for passing parameters to the method [`create_internal_wallet`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateInternalWalletParams {
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
    pub create_wallet_request: Option<models::CreateWalletRequest>,
}

/// struct for passing parameters to the method [`create_internal_wallet_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateInternalWalletAssetParams {
    /// The ID of the wallet
    pub wallet_id: String,
    /// The ID of the asset to add
    pub asset_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
    pub create_internal_wallet_asset_request: Option<models::CreateInternalWalletAssetRequest>,
}

/// struct for passing parameters to the method [`delete_internal_wallet`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteInternalWalletParams {
    /// The ID of the wallet to delete
    pub wallet_id: String,
}

/// struct for passing parameters to the method [`delete_internal_wallet_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteInternalWalletAssetParams {
    /// The ID of the wallet
    pub wallet_id: String,
    /// The ID of the asset to delete
    pub asset_id: String,
}

/// struct for passing parameters to the method [`get_internal_wallet`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetInternalWalletParams {
    /// The ID of the wallet to return
    pub wallet_id: String,
}

/// struct for passing parameters to the method [`get_internal_wallet_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetInternalWalletAssetParams {
    /// The ID of the wallet
    pub wallet_id: String,
    /// The ID of the asset to return
    pub asset_id: String,
}

/// struct for passing parameters to the method
/// [`set_customer_ref_id_for_internal_wallet`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetCustomerRefIdForInternalWalletParams {
    /// The wallet ID
    pub wallet_id: String,
    pub set_customer_ref_id_request: models::SetCustomerRefIdRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

#[async_trait]
impl WhitelistedInternalWalletsApi for WhitelistedInternalWalletsApiClient {
    /// Creates a new internal wallet with the requested name. Learn more about Whitelisted Internal Addresses [here](https://developers.fireblocks.com/docs/whitelist-addresses#internal-wallets)  </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_internal_wallet(
        &self,
        params: CreateInternalWalletParams,
    ) -> Result<models::UnmanagedWallet, Error<CreateInternalWalletError>> {
        let CreateInternalWalletParams {
            idempotency_key,
            create_wallet_request,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/internal_wallets", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&create_wallet_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CreateInternalWalletError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Adds an asset to an existing internal wallet.  Internal Wallets are whitelisted wallets that belong to you outside of Fireblocks.    - You can see the balance of the Internal Wallet via Fireblocks   - You cannot initiate transactions from Internal Wallets through Fireblocks    Learn more about Whitelisted Internal Addresses [here](https://developers.fireblocks.com/docs/whitelist-addresses#internal-wallets) </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_internal_wallet_asset(
        &self,
        params: CreateInternalWalletAssetParams,
    ) -> Result<models::WalletAsset, Error<CreateInternalWalletAssetError>> {
        let CreateInternalWalletAssetParams {
            wallet_id,
            asset_id,
            idempotency_key,
            create_internal_wallet_asset_request,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/internal_wallets/{walletId}/{assetId}",
            local_var_configuration.base_path,
            walletId = crate::apis::urlencode(wallet_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&create_internal_wallet_asset_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CreateInternalWalletAssetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Deletes an internal wallet by ID.  Internal Wallets are whitelisted
    /// wallets that belong to you outside of Fireblocks.    - You can see the
    /// balance of the Internal Wallet via Fireblocks   - You cannot initiate
    /// transactions from Internal Wallets through Fireblocks  </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn delete_internal_wallet(
        &self,
        params: DeleteInternalWalletParams,
    ) -> Result<(), Error<DeleteInternalWalletError>> {
        let DeleteInternalWalletParams { wallet_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/internal_wallets/{walletId}",
            local_var_configuration.base_path,
            walletId = crate::apis::urlencode(wallet_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<DeleteInternalWalletError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Deletes a whitelisted address (for an asset) from an internal wallet.
    /// Internal Wallets are whitelisted wallets that belong to you outside of
    /// Fireblocks.    - You can see the balance of the Internal Wallet via
    /// Fireblocks   - You cannot initiate transactions from Internal Wallets
    /// through Fireblocks  </br>Endpoint Permission: Admin, Non-Signing Admin,
    /// Signer, Approver, Editor.
    async fn delete_internal_wallet_asset(
        &self,
        params: DeleteInternalWalletAssetParams,
    ) -> Result<(), Error<DeleteInternalWalletAssetError>> {
        let DeleteInternalWalletAssetParams {
            wallet_id,
            asset_id,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/internal_wallets/{walletId}/{assetId}",
            local_var_configuration.base_path,
            walletId = crate::apis::urlencode(wallet_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<DeleteInternalWalletAssetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all assets in an internal wallet by ID.  Internal Wallets are
    /// whitelisted wallets that belong to you outside of Fireblocks.    - You
    /// can see the balance of the Internal Wallet via Fireblocks   - You cannot
    /// initiate transactions from Internal Wallets through Fireblocks
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_internal_wallet(
        &self,
        params: GetInternalWalletParams,
    ) -> Result<models::UnmanagedWallet, Error<GetInternalWalletError>> {
        let GetInternalWalletParams { wallet_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/internal_wallets/{walletId}",
            local_var_configuration.base_path,
            walletId = crate::apis::urlencode(wallet_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetInternalWalletError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns information for an asset in an internal wallet.  Internal
    /// Wallets are whitelisted wallets that belong to you outside of
    /// Fireblocks.    - You can see the balance of the Internal Wallet via
    /// Fireblocks   - You cannot initiate transactions from Internal Wallets
    /// through Fireblocks  </br>Endpoint Permission: Admin, Non-Signing Admin,
    /// Signer, Approver, Editor, Viewer.
    async fn get_internal_wallet_asset(
        &self,
        params: GetInternalWalletAssetParams,
    ) -> Result<models::WalletAsset, Error<GetInternalWalletAssetError>> {
        let GetInternalWalletAssetParams {
            wallet_id,
            asset_id,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/internal_wallets/{walletId}/{assetId}",
            local_var_configuration.base_path,
            walletId = crate::apis::urlencode(wallet_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetInternalWalletAssetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets a list of internal wallets.   **Note**: BTC-based assets belonging
    /// to whitelisted addresses cannot be retrieved between 00:00 UTC and 00:01
    /// UTC daily due to third-party provider, Blockchair, being unavailable for
    /// this 60 second period.  Please wait until the next minute to retrieve
    /// BTC-based assets.  Internal Wallets are whitelisted wallets that belong
    /// to you outside of Fireblocks.  - You can see the balance of the Internal
    /// Wallet via Fireblocks - You cannot initiate transactions from Internal
    /// Wallets through Fireblocks </br>Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor, Viewer.
    async fn get_internal_wallets(
        &self,
    ) -> Result<Vec<models::UnmanagedWallet>, Error<GetInternalWalletsError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/internal_wallets", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetInternalWalletsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Sets an AML/KYT customer reference ID for the specific internal wallet.  Internal Wallets are whitelisted wallets that belong to you outside of Fireblocks.    - You can see the balance of the Internal Wallet via Fireblocks   - You cannot initiate transactions from Internal Wallets through Fireblocks    Learn more about Whitelisted Internal Addresses [here](https://developers.fireblocks.com/docs/whitelist-addresses#internal-wallets) </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn set_customer_ref_id_for_internal_wallet(
        &self,
        params: SetCustomerRefIdForInternalWalletParams,
    ) -> Result<(), Error<SetCustomerRefIdForInternalWalletError>> {
        let SetCustomerRefIdForInternalWalletParams {
            wallet_id,
            set_customer_ref_id_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/internal_wallets/{walletId}/set_customer_ref_id",
            local_var_configuration.base_path,
            walletId = crate::apis::urlencode(wallet_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&set_customer_ref_id_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<SetCustomerRefIdForInternalWalletError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed errors of method [`create_internal_wallet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInternalWalletError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_internal_wallet_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInternalWalletAssetError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_internal_wallet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInternalWalletError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_internal_wallet_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInternalWalletAssetError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_internal_wallet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInternalWalletError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_internal_wallet_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInternalWalletAssetError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_internal_wallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInternalWalletsError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`set_customer_ref_id_for_internal_wallet`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCustomerRefIdForInternalWalletError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}
