/*
 * Fireblocks API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.5
 * Contact: support@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait BlockchainsAssetsApi: Send + Sync {
    async fn estimate_network_fee_get(&self,  params: EstimateNetworkFeeGetParams ) -> Result<models::EstimatedNetworkFeeResponse, Error<EstimateNetworkFeeGetError>>;
    async fn register_new_asset(&self,  params: RegisterNewAssetParams ) -> Result<models::AssetResponse, Error<RegisterNewAssetError>>;
    async fn supported_assets_get(&self, ) -> Result<Vec<models::AssetTypeResponse>, Error<SupportedAssetsGetError>>;
    async fn transactions_validate_address_asset_id_address_get(&self,  params: TransactionsValidateAddressAssetIdAddressGetParams ) -> Result<models::ValidateAddressResponse, Error<TransactionsValidateAddressAssetIdAddressGetError>>;
}

pub struct BlockchainsAssetsApiClient {
    configuration: Arc<configuration::Configuration>
}

impl BlockchainsAssetsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`estimate_network_fee_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct EstimateNetworkFeeGetParams {
    /// The asset for which to estimate the fee
    pub asset_id: String
}

/// struct for passing parameters to the method [`register_new_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RegisterNewAssetParams {
    pub register_new_asset_request: Option<models::RegisterNewAssetRequest>
}

/// struct for passing parameters to the method [`transactions_validate_address_asset_id_address_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct TransactionsValidateAddressAssetIdAddressGetParams {
    /// The asset of the address
    pub asset_id: String,
    /// The address to validate
    pub address: String
}


#[async_trait]
impl BlockchainsAssetsApi for BlockchainsAssetsApiClient {
    /// Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
    async fn estimate_network_fee_get(&self,  params: EstimateNetworkFeeGetParams ) -> Result<models::EstimatedNetworkFeeResponse, Error<EstimateNetworkFeeGetError>> {
        
        let EstimateNetworkFeeGetParams {
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/estimate_network_fee", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        local_var_req_builder = local_var_req_builder.query(&[("assetId", &asset_id.to_string())]);
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<EstimateNetworkFeeGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Register a new asset to a workspace and return the newly created asset's details. Currently supported chains are: - EVM based chains - Stellar - Algorand - TRON - NEAR - Solana 
    async fn register_new_asset(&self,  params: RegisterNewAssetParams ) -> Result<models::AssetResponse, Error<RegisterNewAssetError>> {
        
        let RegisterNewAssetParams {
            register_new_asset_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/assets", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&register_new_asset_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<RegisterNewAssetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all assets and assets types supported by Fireblocks.
    async fn supported_assets_get(&self, ) -> Result<Vec<models::AssetTypeResponse>, Error<SupportedAssetsGetError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/supported_assets", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SupportedAssetsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Checks if an address is valid (for XRP, DOT, XLM, and EOS).
    async fn transactions_validate_address_asset_id_address_get(&self,  params: TransactionsValidateAddressAssetIdAddressGetParams ) -> Result<models::ValidateAddressResponse, Error<TransactionsValidateAddressAssetIdAddressGetError>> {
        
        let TransactionsValidateAddressAssetIdAddressGetParams {
            asset_id,
            address,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/transactions/validate_address/{assetId}/{address}", local_var_configuration.base_path, assetId=crate::apis::urlencode(asset_id), address=crate::apis::urlencode(address));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<TransactionsValidateAddressAssetIdAddressGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`estimate_network_fee_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EstimateNetworkFeeGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_new_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterNewAssetError {
    Status400(models::AssetBadRequestErrorResponse),
    Status403(models::AssetForbiddenErrorResponse),
    Status404(models::AssetNotFoundErrorResponse),
    Status409(models::AssetConflictErrorResponse),
    Status500(models::AssetInternalServerErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`supported_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SupportedAssetsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transactions_validate_address_asset_id_address_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionsValidateAddressAssetIdAddressGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

