// Fireblocks API
//
// Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com)
//
// The version of the OpenAPI document: 1.8.0
// Contact: developers@fireblocks.com
// Generated by: https://openapi-generator.tech

use {
    super::{configuration, Error},
    crate::{apis::ResponseContent, models},
    async_trait::async_trait,
    reqwest,
    serde::{Deserialize, Serialize},
    std::sync::Arc,
};

#[async_trait]
pub trait ContractInteractionsApi: Send + Sync {
    async fn get_deployed_contract_abi(
        &self,
        params: GetDeployedContractAbiParams,
    ) -> Result<models::ContractAbiResponseDto, Error<GetDeployedContractAbiError>>;
    async fn get_transaction_receipt(
        &self,
        params: GetTransactionReceiptParams,
    ) -> Result<models::TransactionReceiptResponse, Error<GetTransactionReceiptError>>;
    async fn read_call_function(
        &self,
        params: ReadCallFunctionParams,
    ) -> Result<Vec<models::ParameterWithValue>, Error<ReadCallFunctionError>>;
    async fn write_call_function(
        &self,
        params: WriteCallFunctionParams,
    ) -> Result<models::WriteCallFunctionResponseDto, Error<WriteCallFunctionError>>;
}

pub struct ContractInteractionsApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl ContractInteractionsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

/// struct for passing parameters to the method [`get_deployed_contract_abi`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetDeployedContractAbiParams {
    /// The contract's onchain address
    pub contract_address: String,
    /// The blockchain base assetId
    pub base_asset_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`get_transaction_receipt`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetTransactionReceiptParams {
    /// The blockchain base assetId
    pub base_asset_id: String,
    /// The transaction hash
    pub tx_hash: String,
}

/// struct for passing parameters to the method [`read_call_function`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ReadCallFunctionParams {
    /// The contract's onchain address
    pub contract_address: String,
    /// The blockchain base assetId
    pub base_asset_id: String,
    pub read_call_function_dto: models::ReadCallFunctionDto,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`write_call_function`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct WriteCallFunctionParams {
    /// The contract's onchain address
    pub contract_address: String,
    /// The blockchain base assetId
    pub base_asset_id: String,
    pub write_call_function_dto: models::WriteCallFunctionDto,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

#[async_trait]
impl ContractInteractionsApi for ContractInteractionsApiClient {
    /// Return deployed contract's ABI by blockchain native asset id and
    /// contract address. </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn get_deployed_contract_abi(
        &self,
        params: GetDeployedContractAbiParams,
    ) -> Result<models::ContractAbiResponseDto, Error<GetDeployedContractAbiError>> {
        let GetDeployedContractAbiParams {
            contract_address,
            base_asset_id,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/contract_interactions/base_asset_id/{baseAssetId}/contract_address/\
             {contractAddress}/functions",
            local_var_configuration.base_path,
            contractAddress = crate::apis::urlencode(contract_address),
            baseAssetId = crate::apis::urlencode(base_asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetDeployedContractAbiError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Retrieve the transaction receipt by blockchain native asset ID and
    /// transaction hash  </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn get_transaction_receipt(
        &self,
        params: GetTransactionReceiptParams,
    ) -> Result<models::TransactionReceiptResponse, Error<GetTransactionReceiptError>> {
        let GetTransactionReceiptParams {
            base_asset_id,
            tx_hash,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/contract_interactions/base_asset_id/{baseAssetId}/tx_hash/{txHash}/receipt",
            local_var_configuration.base_path,
            baseAssetId = crate::apis::urlencode(base_asset_id),
            txHash = crate::apis::urlencode(tx_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetTransactionReceiptError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Call a read function on a deployed contract by blockchain native asset
    /// id and contract address. </br>Endpoint Permission: Admin, Non-Signing
    /// Admin.
    async fn read_call_function(
        &self,
        params: ReadCallFunctionParams,
    ) -> Result<Vec<models::ParameterWithValue>, Error<ReadCallFunctionError>> {
        let ReadCallFunctionParams {
            contract_address,
            base_asset_id,
            read_call_function_dto,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/contract_interactions/base_asset_id/{baseAssetId}/contract_address/\
             {contractAddress}/functions/read",
            local_var_configuration.base_path,
            contractAddress = crate::apis::urlencode(contract_address),
            baseAssetId = crate::apis::urlencode(base_asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&read_call_function_dto);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<ReadCallFunctionError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Call a write function on a deployed contract by blockchain native asset
    /// id and contract address. This creates an onchain transaction, thus it is
    /// an async operation. It returns a transaction id that can be polled for
    /// status check.  </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn write_call_function(
        &self,
        params: WriteCallFunctionParams,
    ) -> Result<models::WriteCallFunctionResponseDto, Error<WriteCallFunctionError>> {
        let WriteCallFunctionParams {
            contract_address,
            base_asset_id,
            write_call_function_dto,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/contract_interactions/base_asset_id/{baseAssetId}/contract_address/\
             {contractAddress}/functions/write",
            local_var_configuration.base_path,
            contractAddress = crate::apis::urlencode(contract_address),
            baseAssetId = crate::apis::urlencode(base_asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&write_call_function_dto);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<WriteCallFunctionError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed errors of method [`get_deployed_contract_abi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDeployedContractAbiError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_receipt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionReceiptError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`read_call_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReadCallFunctionError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`write_call_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WriteCallFunctionError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}
