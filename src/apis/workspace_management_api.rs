/*
 * Fireblocks API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.5
 * Contact: support@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait WorkspaceManagementApi: Send + Sync {
    async fn create_user_group(&self,  params: CreateUserGroupParams ) -> Result<models::CreateUserGroupResponse, Error<CreateUserGroupError>>;
    async fn delete_user_group(&self,  params: DeleteUserGroupParams ) -> Result<(), Error<DeleteUserGroupError>>;
    async fn get_audits(&self,  params: GetAuditsParams ) -> Result<(), Error<GetAuditsError>>;
    async fn get_ota_status(&self, ) -> Result<models::GetOtaStatus200Response, Error<GetOtaStatusError>>;
    async fn get_user_group(&self,  params: GetUserGroupParams ) -> Result<models::UserGroupResponse, Error<GetUserGroupError>>;
    async fn get_user_groups(&self, ) -> Result<Vec<models::UserGroupResponse>, Error<GetUserGroupsError>>;
    async fn get_workspace_status(&self, ) -> Result<models::GetWorkspaceStatus200Response, Error<GetWorkspaceStatusError>>;
    async fn management_api_users_get(&self, ) -> Result<(), Error<ManagementApiUsersGetError>>;
    async fn management_api_users_post(&self,  params: ManagementApiUsersPostParams ) -> Result<(), Error<ManagementApiUsersPostError>>;
    async fn management_api_users_user_id_whitelist_ip_addresses_get(&self,  params: ManagementApiUsersUserIdWhitelistIpAddressesGetParams ) -> Result<(), Error<ManagementApiUsersUserIdWhitelistIpAddressesGetError>>;
    async fn management_users_get(&self, ) -> Result<(), Error<ManagementUsersGetError>>;
    async fn management_users_id_reset_device_post(&self,  params: ManagementUsersIdResetDevicePostParams ) -> Result<(), Error<ManagementUsersIdResetDevicePostError>>;
    async fn management_users_post(&self,  params: ManagementUsersPostParams ) -> Result<(), Error<ManagementUsersPostError>>;
    async fn set_ota_status(&self,  params: SetOtaStatusParams ) -> Result<(), Error<SetOtaStatusError>>;
    async fn update_user_group(&self,  params: UpdateUserGroupParams ) -> Result<models::UserGroupCreateResponse, Error<UpdateUserGroupError>>;
}

pub struct WorkspaceManagementApiClient {
    configuration: Arc<configuration::Configuration>
}

impl WorkspaceManagementApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`create_user_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateUserGroupParams {
    pub user_group_create_request: models::UserGroupCreateRequest
}

/// struct for passing parameters to the method [`delete_user_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteUserGroupParams {
    /// The ID of the users group
    pub group_id: String
}

/// struct for passing parameters to the method [`get_audits`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetAuditsParams {
    /// The final time period to fetch audit logs (day/week)
    pub time_period: Option<String>,
    /// The next ID to start fetching audit logs from
    pub cursor: Option<String>
}

/// struct for passing parameters to the method [`get_user_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetUserGroupParams {
    /// The ID of the users group
    pub group_id: String
}

/// struct for passing parameters to the method [`management_api_users_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ManagementApiUsersPostParams {
    pub create_api_user: Option<models::CreateApiUser>
}

/// struct for passing parameters to the method [`management_api_users_user_id_whitelist_ip_addresses_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ManagementApiUsersUserIdWhitelistIpAddressesGetParams {
    /// The ID of the user
    pub user_id: String
}

/// struct for passing parameters to the method [`management_users_id_reset_device_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ManagementUsersIdResetDevicePostParams {
    /// The userâ€™s ID
    pub id: String
}

/// struct for passing parameters to the method [`management_users_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ManagementUsersPostParams {
    pub create_console_user: Option<models::CreateConsoleUser>
}

/// struct for passing parameters to the method [`set_ota_status`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetOtaStatusParams {
    pub set_ota_status_request: models::SetOtaStatusRequest
}

/// struct for passing parameters to the method [`update_user_group`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateUserGroupParams {
    /// The ID of the users group
    pub group_id: String,
    pub user_group_update_request: models::UserGroupUpdateRequest
}


#[async_trait]
impl WorkspaceManagementApi for WorkspaceManagementApiClient {
    /// Create a new user group.</br> 
    async fn create_user_group(&self,  params: CreateUserGroupParams ) -> Result<models::CreateUserGroupResponse, Error<CreateUserGroupError>> {
        
        let CreateUserGroupParams {
            user_group_create_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/user_groups", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&user_group_create_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CreateUserGroupError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Delete a user group by ID.</br>  **Note**: - Please note that this endpoint is available only for API keys with Admin permissions. 
    async fn delete_user_group(&self,  params: DeleteUserGroupParams ) -> Result<(), Error<DeleteUserGroupError>> {
        
        let DeleteUserGroupParams {
            group_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/user_groups/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<DeleteUserGroupError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get audit logs
    async fn get_audits(&self,  params: GetAuditsParams ) -> Result<(), Error<GetAuditsError>> {
        
        let GetAuditsParams {
            time_period,
            cursor,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/audit_logs", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = time_period {
            local_var_req_builder = local_var_req_builder.query(&[("timePeriod", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = cursor {
            local_var_req_builder = local_var_req_builder.query(&[("cursor", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<GetAuditsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns current One Time Address (OTA) status
    async fn get_ota_status(&self, ) -> Result<models::GetOtaStatus200Response, Error<GetOtaStatusError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/ota", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetOtaStatusError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get a user group by ID.</br> 
    async fn get_user_group(&self,  params: GetUserGroupParams ) -> Result<models::UserGroupResponse, Error<GetUserGroupError>> {
        
        let GetUserGroupParams {
            group_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/user_groups/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetUserGroupError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get all user groups in the current workspace. 
    async fn get_user_groups(&self, ) -> Result<Vec<models::UserGroupResponse>, Error<GetUserGroupsError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/user_groups", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetUserGroupsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns the status of the current workspace. 
    async fn get_workspace_status(&self, ) -> Result<models::GetWorkspaceStatus200Response, Error<GetWorkspaceStatusError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/workspace_status", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetWorkspaceStatusError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get API users from the current tenant. </br> - **Note: This endpoint is in beta and subject to change** 
    async fn management_api_users_get(&self, ) -> Result<(), Error<ManagementApiUsersGetError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/api_users", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ManagementApiUsersGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates an API user. - **Note: This endpoint is in beta and subject to change** 
    async fn management_api_users_post(&self,  params: ManagementApiUsersPostParams ) -> Result<(), Error<ManagementApiUsersPostError>> {
        
        let ManagementApiUsersPostParams {
            create_api_user,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/api_users", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&create_api_user);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ManagementApiUsersPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets a list of whitelisted IP addresses, which make it possible to get API calls only from these IP addresses.
    async fn management_api_users_user_id_whitelist_ip_addresses_get(&self,  params: ManagementApiUsersUserIdWhitelistIpAddressesGetParams ) -> Result<(), Error<ManagementApiUsersUserIdWhitelistIpAddressesGetError>> {
        
        let ManagementApiUsersUserIdWhitelistIpAddressesGetParams {
            user_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/api_users/{userId}/whitelist_ip_addresses", local_var_configuration.base_path, userId=crate::apis::urlencode(user_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ManagementApiUsersUserIdWhitelistIpAddressesGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets a list of Console users from the current tenant.
    async fn management_users_get(&self, ) -> Result<(), Error<ManagementUsersGetError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/users", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ManagementUsersGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Re-links a mobile device to the workspace
    async fn management_users_id_reset_device_post(&self,  params: ManagementUsersIdResetDevicePostParams ) -> Result<(), Error<ManagementUsersIdResetDevicePostError>> {
        
        let ManagementUsersIdResetDevicePostParams {
            id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/users/{id}/reset_device", local_var_configuration.base_path, id=crate::apis::urlencode(id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ManagementUsersIdResetDevicePostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a Fireblocks Console user
    async fn management_users_post(&self,  params: ManagementUsersPostParams ) -> Result<(), Error<ManagementUsersPostError>> {
        
        let ManagementUsersPostParams {
            create_console_user,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/users", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&create_console_user);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<ManagementUsersPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Enable or disable transactions to One Time Address (OTA)
    async fn set_ota_status(&self,  params: SetOtaStatusParams ) -> Result<(), Error<SetOtaStatusError>> {
        
        let SetOtaStatusParams {
            set_ota_status_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/ota", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&set_ota_status_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<SetOtaStatusError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Update a users group by ID.</br>  **Note**: - Please note that this endpoint is available only for API keys with Admin permissions. 
    async fn update_user_group(&self,  params: UpdateUserGroupParams ) -> Result<models::UserGroupCreateResponse, Error<UpdateUserGroupError>> {
        
        let UpdateUserGroupParams {
            group_id,
            user_group_update_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/management/user_groups/{groupId}", local_var_configuration.base_path, groupId=crate::apis::urlencode(group_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&user_group_update_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<UpdateUserGroupError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`create_user_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserGroupError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserGroupError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_audits`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAuditsError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ota_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOtaStatusError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserGroupError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserGroupsError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_workspace_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkspaceStatusError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`management_api_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManagementApiUsersGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status5XX(models::ErrorResponse),
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`management_api_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManagementApiUsersPostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status5XX(models::ErrorResponse),
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`management_api_users_user_id_whitelist_ip_addresses_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManagementApiUsersUserIdWhitelistIpAddressesGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status5XX(models::ErrorResponse),
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`management_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManagementUsersGetError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status5XX(models::ErrorResponse),
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`management_users_id_reset_device_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManagementUsersIdResetDevicePostError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status5XX(models::ErrorResponse),
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`management_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManagementUsersPostError {
    Status400(),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status5XX(models::ErrorResponse),
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_ota_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetOtaStatusError {
    Status400(),
    Status409(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserGroupError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

