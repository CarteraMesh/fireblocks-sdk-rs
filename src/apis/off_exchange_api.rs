/*
 * Fireblocks API
 *
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.8.0
 * Contact: developers@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait OffExchangeApi: Send + Sync {
    async fn add_off_exchange(&self,  params: AddOffExchangeParams ) -> Result<models::CreateTransactionResponse, Error<AddOffExchangeError>>;
    async fn get_off_exchange_collateral_accounts(&self,  params: GetOffExchangeCollateralAccountsParams ) -> Result<models::ExchangeAccount, Error<GetOffExchangeCollateralAccountsError>>;
    async fn get_off_exchange_settlement_transactions(&self,  params: GetOffExchangeSettlementTransactionsParams ) -> Result<models::ExchangeSettlementTransactionsResponse, Error<GetOffExchangeSettlementTransactionsError>>;
    async fn remove_off_exchange(&self,  params: RemoveOffExchangeParams ) -> Result<models::CreateTransactionResponse, Error<RemoveOffExchangeError>>;
    async fn settle_off_exchange_trades(&self,  params: SettleOffExchangeTradesParams ) -> Result<models::SettlementResponse, Error<SettleOffExchangeTradesError>>;
}

pub struct OffExchangeApiClient {
    configuration: Arc<configuration::Configuration>
}

impl OffExchangeApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`add_off_exchange`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct AddOffExchangeParams {
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>,
    pub add_collateral_request_body: Option<models::AddCollateralRequestBody>
}

/// struct for passing parameters to the method [`get_off_exchange_collateral_accounts`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetOffExchangeCollateralAccountsParams {
    /// The id of the main exchange account for which the requested collateral account is associated with
    pub main_exchange_account_id: String
}

/// struct for passing parameters to the method [`get_off_exchange_settlement_transactions`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetOffExchangeSettlementTransactionsParams {
    pub main_exchange_account_id: String
}

/// struct for passing parameters to the method [`remove_off_exchange`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RemoveOffExchangeParams {
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>,
    pub remove_collateral_request_body: Option<models::RemoveCollateralRequestBody>
}

/// struct for passing parameters to the method [`settle_off_exchange_trades`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SettleOffExchangeTradesParams {
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>,
    pub settlement_request_body: Option<models::SettlementRequestBody>
}


#[async_trait]
impl OffExchangeApi for OffExchangeApiClient {
    /// add collateral, create deposit request
    async fn add_off_exchange(&self,  params: AddOffExchangeParams ) -> Result<models::CreateTransactionResponse, Error<AddOffExchangeError>> {
        
        let AddOffExchangeParams {
            idempotency_key,
            add_collateral_request_body,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/off_exchange/add", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&add_collateral_request_body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<AddOffExchangeError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a collateral account by mainExchangeAccountId.
    async fn get_off_exchange_collateral_accounts(&self,  params: GetOffExchangeCollateralAccountsParams ) -> Result<models::ExchangeAccount, Error<GetOffExchangeCollateralAccountsError>> {
        
        let GetOffExchangeCollateralAccountsParams {
            main_exchange_account_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/off_exchange/collateral_accounts/{mainExchangeAccountId}", local_var_configuration.base_path, mainExchangeAccountId=crate::apis::urlencode(main_exchange_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetOffExchangeCollateralAccountsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// get settlements transactions from exchange
    async fn get_off_exchange_settlement_transactions(&self,  params: GetOffExchangeSettlementTransactionsParams ) -> Result<models::ExchangeSettlementTransactionsResponse, Error<GetOffExchangeSettlementTransactionsError>> {
        
        let GetOffExchangeSettlementTransactionsParams {
            main_exchange_account_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/off_exchange/settlements/transactions", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        local_var_req_builder = local_var_req_builder.query(&[("mainExchangeAccountId", &main_exchange_account_id.to_string())]);
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetOffExchangeSettlementTransactionsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// remove collateral, create withdraw request
    async fn remove_off_exchange(&self,  params: RemoveOffExchangeParams ) -> Result<models::CreateTransactionResponse, Error<RemoveOffExchangeError>> {
        
        let RemoveOffExchangeParams {
            idempotency_key,
            remove_collateral_request_body,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/off_exchange/remove", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&remove_collateral_request_body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<RemoveOffExchangeError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// create settlement for a trader
    async fn settle_off_exchange_trades(&self,  params: SettleOffExchangeTradesParams ) -> Result<models::SettlementResponse, Error<SettleOffExchangeTradesError>> {
        
        let SettleOffExchangeTradesParams {
            idempotency_key,
            settlement_request_body,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/off_exchange/settlements/trader", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&settlement_request_body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SettleOffExchangeTradesError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`add_off_exchange`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddOffExchangeError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_off_exchange_collateral_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOffExchangeCollateralAccountsError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_off_exchange_settlement_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOffExchangeSettlementTransactionsError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_off_exchange`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveOffExchangeError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`settle_off_exchange_trades`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SettleOffExchangeTradesError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

