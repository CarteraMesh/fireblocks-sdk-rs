/*
 * Fireblocks API
 *
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.8.0
 * Contact: developers@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait SmartTransfersApi: Send + Sync {
    async fn cancel_ticket(&self,  params: CancelTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<CancelTicketError>>;
    async fn create_ticket(&self,  params: CreateTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<CreateTicketError>>;
    async fn create_ticket_term(&self,  params: CreateTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<CreateTicketTermError>>;
    async fn find_ticket_by_id(&self,  params: FindTicketByIdParams ) -> Result<models::SmartTransferTicketResponse, Error<FindTicketByIdError>>;
    async fn find_ticket_term_by_id(&self,  params: FindTicketTermByIdParams ) -> Result<models::SmartTransferTicketTermResponse, Error<FindTicketTermByIdError>>;
    async fn fulfill_ticket(&self,  params: FulfillTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<FulfillTicketError>>;
    async fn fund_ticket_term(&self,  params: FundTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<FundTicketTermError>>;
    async fn get_smart_transfer_user_groups(&self, ) -> Result<models::SmartTransferUserGroupsResponse, Error<GetSmartTransferUserGroupsError>>;
    async fn manually_fund_ticket_term(&self,  params: ManuallyFundTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<ManuallyFundTicketTermError>>;
    async fn remove_ticket_term(&self,  params: RemoveTicketTermParams ) -> Result<(), Error<RemoveTicketTermError>>;
    async fn search_tickets(&self,  params: SearchTicketsParams ) -> Result<models::SmartTransferTicketFilteredResponse, Error<SearchTicketsError>>;
    async fn set_external_ref_id(&self,  params: SetExternalRefIdParams ) -> Result<models::SmartTransferTicketResponse, Error<SetExternalRefIdError>>;
    async fn set_ticket_expiration(&self,  params: SetTicketExpirationParams ) -> Result<models::SmartTransferTicketResponse, Error<SetTicketExpirationError>>;
    async fn set_user_groups(&self,  params: SetUserGroupsParams ) -> Result<models::SmartTransferUserGroupsResponse, Error<SetUserGroupsError>>;
    async fn submit_ticket(&self,  params: SubmitTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<SubmitTicketError>>;
    async fn update_ticket_term(&self,  params: UpdateTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<UpdateTicketTermError>>;
}

pub struct SmartTransfersApiClient {
    configuration: Arc<configuration::Configuration>
}

impl SmartTransfersApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`cancel_ticket`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CancelTicketParams {
    pub ticket_id: String,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`create_ticket`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateTicketParams {
    pub smart_transfer_create_ticket: models::SmartTransferCreateTicket,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`create_ticket_term`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateTicketTermParams {
    pub ticket_id: String,
    pub smart_transfer_create_ticket_term: models::SmartTransferCreateTicketTerm,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`find_ticket_by_id`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct FindTicketByIdParams {
    pub ticket_id: String
}

/// struct for passing parameters to the method [`find_ticket_term_by_id`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct FindTicketTermByIdParams {
    pub ticket_id: String,
    pub term_id: String
}

/// struct for passing parameters to the method [`fulfill_ticket`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct FulfillTicketParams {
    pub ticket_id: String,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`fund_ticket_term`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct FundTicketTermParams {
    pub ticket_id: String,
    pub term_id: String,
    pub smart_transfer_fund_term: models::SmartTransferFundTerm,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`manually_fund_ticket_term`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ManuallyFundTicketTermParams {
    pub ticket_id: String,
    pub term_id: String,
    pub smart_transfer_manually_fund_term: models::SmartTransferManuallyFundTerm,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`remove_ticket_term`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RemoveTicketTermParams {
    pub ticket_id: String,
    pub term_id: String
}

/// struct for passing parameters to the method [`search_tickets`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SearchTicketsParams {
    /// Search string - counterparty name or asset or ticketId. Optional
    pub q: Option<String>,
    /// Ticket statuses for Smart Transfer tickets. Optional
    pub statuses: Option<Vec<String>>,
    /// NetworkId that is used in the ticket . Optional
    pub network_id: Option<String>,
    /// Filter created tickets by created by self or by others. Optional
    pub created_by_me: Option<bool>,
    /// Lower bound of search range. Optional
    pub expires_after: Option<String>,
    /// Upper bound of search range. Optional
    pub expires_before: Option<String>,
    /// Type of transfer. ASYNC executes transfers as they are funded, ATOMIC executes all terms (legs) as one atomic transfer
    pub r#type: Option<String>,
    /// External ref. ID that workspace can use to identify ticket outside of Fireblocks system.
    pub external_ref_id: Option<String>,
    /// ID of the record after which to fetch $limit records
    pub after: Option<String>,
    /// Number of records to fetch. By default, it is 100
    pub limit: Option<f64>
}

/// struct for passing parameters to the method [`set_external_ref_id`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetExternalRefIdParams {
    pub ticket_id: String,
    pub smart_transfer_set_ticket_external_id: models::SmartTransferSetTicketExternalId,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`set_ticket_expiration`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetTicketExpirationParams {
    pub ticket_id: String,
    pub smart_transfer_set_ticket_expiration: models::SmartTransferSetTicketExpiration,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`set_user_groups`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetUserGroupsParams {
    pub smart_transfer_set_user_groups: models::SmartTransferSetUserGroups,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`submit_ticket`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SubmitTicketParams {
    pub ticket_id: String,
    pub smart_transfer_submit_ticket: models::SmartTransferSubmitTicket,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`update_ticket_term`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateTicketTermParams {
    pub ticket_id: String,
    pub term_id: String,
    pub smart_transfer_update_ticket_term: models::SmartTransferUpdateTicketTerm,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}


#[async_trait]
impl SmartTransfersApi for SmartTransfersApiClient {
    /// Cancel Smart Transfer ticket
    async fn cancel_ticket(&self,  params: CancelTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<CancelTicketError>> {
        
        let CancelTicketParams {
            ticket_id,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/cancel", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CancelTicketError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates new Smart Transfer ticket
    async fn create_ticket(&self,  params: CreateTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<CreateTicketError>> {
        
        let CreateTicketParams {
            smart_transfer_create_ticket,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_create_ticket);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CreateTicketError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates new smart transfer ticket term (when the ticket status is DRAFT)
    async fn create_ticket_term(&self,  params: CreateTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<CreateTicketTermError>> {
        
        let CreateTicketTermParams {
            ticket_id,
            smart_transfer_create_ticket_term,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/terms", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_create_ticket_term);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CreateTicketTermError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Find Smart Transfer ticket by id
    async fn find_ticket_by_id(&self,  params: FindTicketByIdParams ) -> Result<models::SmartTransferTicketResponse, Error<FindTicketByIdError>> {
        
        let FindTicketByIdParams {
            ticket_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<FindTicketByIdError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Find a specific term of a specific Smart Transfer ticket
    async fn find_ticket_term_by_id(&self,  params: FindTicketTermByIdParams ) -> Result<models::SmartTransferTicketTermResponse, Error<FindTicketTermByIdError>> {
        
        let FindTicketTermByIdParams {
            ticket_id,
            term_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/terms/{termId}", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id), termId=crate::apis::urlencode(term_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<FindTicketTermByIdError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Manually fulfill ticket, in case when all terms (legs) are funded manually
    async fn fulfill_ticket(&self,  params: FulfillTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<FulfillTicketError>> {
        
        let FulfillTicketParams {
            ticket_id,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/fulfill", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<FulfillTicketError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
    async fn fund_ticket_term(&self,  params: FundTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<FundTicketTermError>> {
        
        let FundTicketTermParams {
            ticket_id,
            term_id,
            smart_transfer_fund_term,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/terms/{termId}/fund", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id), termId=crate::apis::urlencode(term_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_fund_term);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<FundTicketTermError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get Smart Transfer user groups
    async fn get_smart_transfer_user_groups(&self, ) -> Result<models::SmartTransferUserGroupsResponse, Error<GetSmartTransferUserGroupsError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/settings/user-groups", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetSmartTransferUserGroupsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Manually set ticket term transaction
    async fn manually_fund_ticket_term(&self,  params: ManuallyFundTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<ManuallyFundTicketTermError>> {
        
        let ManuallyFundTicketTermParams {
            ticket_id,
            term_id,
            smart_transfer_manually_fund_term,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/terms/{termId}/manually-fund", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id), termId=crate::apis::urlencode(term_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_manually_fund_term);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<ManuallyFundTicketTermError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Delete ticket term when ticket is in DRAFT status
    async fn remove_ticket_term(&self,  params: RemoveTicketTermParams ) -> Result<(), Error<RemoveTicketTermError>> {
        
        let RemoveTicketTermParams {
            ticket_id,
            term_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/terms/{termId}", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id), termId=crate::apis::urlencode(term_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<RemoveTicketTermError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Finds Smart Transfer tickets that match the submitted criteria
    async fn search_tickets(&self,  params: SearchTicketsParams ) -> Result<models::SmartTransferTicketFilteredResponse, Error<SearchTicketsError>> {
        
        let SearchTicketsParams {
            q,
            statuses,
            network_id,
            created_by_me,
            expires_after,
            expires_before,
            r#type,
            external_ref_id,
            after,
            limit,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = q {
            local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = statuses {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("statuses".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("statuses", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref local_var_str) = network_id {
            local_var_req_builder = local_var_req_builder.query(&[("networkId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = created_by_me {
            local_var_req_builder = local_var_req_builder.query(&[("createdByMe", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expires_after {
            local_var_req_builder = local_var_req_builder.query(&[("expiresAfter", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = expires_before {
            local_var_req_builder = local_var_req_builder.query(&[("expiresBefore", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = r#type {
            local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = external_ref_id {
            local_var_req_builder = local_var_req_builder.query(&[("externalRefId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder = local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SearchTicketsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Set external id Smart Transfer ticket
    async fn set_external_ref_id(&self,  params: SetExternalRefIdParams ) -> Result<models::SmartTransferTicketResponse, Error<SetExternalRefIdError>> {
        
        let SetExternalRefIdParams {
            ticket_id,
            smart_transfer_set_ticket_external_id,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/external-id", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_set_ticket_external_id);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SetExternalRefIdError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Set expiration date on Smart Transfer ticket
    async fn set_ticket_expiration(&self,  params: SetTicketExpirationParams ) -> Result<models::SmartTransferTicketResponse, Error<SetTicketExpirationError>> {
        
        let SetTicketExpirationParams {
            ticket_id,
            smart_transfer_set_ticket_expiration,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/expires-in", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_set_ticket_expiration);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SetTicketExpirationError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Set Smart Transfers user group to receive email notifications for Smart Transfers
    async fn set_user_groups(&self,  params: SetUserGroupsParams ) -> Result<models::SmartTransferUserGroupsResponse, Error<SetUserGroupsError>> {
        
        let SetUserGroupsParams {
            smart_transfer_set_user_groups,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/settings/user-groups", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_set_user_groups);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SetUserGroupsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
    async fn submit_ticket(&self,  params: SubmitTicketParams ) -> Result<models::SmartTransferTicketResponse, Error<SubmitTicketError>> {
        
        let SubmitTicketParams {
            ticket_id,
            smart_transfer_submit_ticket,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/submit", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_submit_ticket);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SubmitTicketError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Update ticket term (when ticket status is DRAFT)
    async fn update_ticket_term(&self,  params: UpdateTicketTermParams ) -> Result<models::SmartTransferTicketTermResponse, Error<UpdateTicketTermError>> {
        
        let UpdateTicketTermParams {
            ticket_id,
            term_id,
            smart_transfer_update_ticket_term,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/smart-transfers/{ticketId}/terms/{termId}", local_var_configuration.base_path, ticketId=crate::apis::urlencode(ticket_id), termId=crate::apis::urlencode(term_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&smart_transfer_update_ticket_term);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<UpdateTicketTermError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`cancel_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelTicketError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTicketError {
    Status403(models::SmartTransferForbiddenResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ticket_term`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTicketTermError {
    Status403(models::SmartTransferForbiddenResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_ticket_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindTicketByIdError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_ticket_term_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindTicketTermByIdError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fulfill_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FulfillTicketError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fund_ticket_term`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FundTicketTermError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_smart_transfer_user_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSmartTransferUserGroupsError {
    Status403(models::SmartTransferForbiddenResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manually_fund_ticket_term`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManuallyFundTicketTermError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_ticket_term`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveTicketTermError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_tickets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchTicketsError {
    Status403(models::SmartTransferForbiddenResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_external_ref_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetExternalRefIdError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_ticket_expiration`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetTicketExpirationError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_user_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetUserGroupsError {
    Status403(models::SmartTransferForbiddenResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitTicketError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    Status422(models::SmartTransferBadRequestResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_ticket_term`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTicketTermError {
    Status403(models::SmartTransferForbiddenResponse),
    Status404(models::SmartTransferNotFoundResponse),
    UnknownValue(serde_json::Value),
}

