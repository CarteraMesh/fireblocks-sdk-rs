/*
 * Fireblocks API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.5
 * Contact: support@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait VaultsApi: Send + Sync {
    async fn create_vault_account_asset_address(&self,  params: CreateVaultAccountAssetAddressParams ) -> Result<models::CreateAddressResponse, Error<CreateVaultAccountAssetAddressError>>;
    async fn vault_accounts_get(&self,  params: VaultAccountsGetParams ) -> Result<Vec<models::VaultAccount>, Error<VaultAccountsGetError>>;
    async fn vault_accounts_paged_get(&self,  params: VaultAccountsPagedGetParams ) -> Result<models::VaultAccountsPagedResponse, Error<VaultAccountsPagedGetError>>;
    async fn vault_accounts_post(&self,  params: VaultAccountsPostParams ) -> Result<models::VaultAccount, Error<VaultAccountsPostError>>;
    async fn vault_accounts_vault_account_id_asset_id_activate_post(&self,  params: VaultAccountsVaultAccountIdAssetIdActivatePostParams ) -> Result<models::CreateVaultAssetResponse, Error<VaultAccountsVaultAccountIdAssetIdActivatePostError>>;
    async fn vault_accounts_vault_account_id_asset_id_addresses_address_id_create_legacy_post(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostParams ) -> Result<models::CreateAddressResponse, Error<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostError>>;
    async fn vault_accounts_vault_account_id_asset_id_addresses_address_id_put(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutParams ) -> Result<(), Error<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutError>>;
    async fn vault_accounts_vault_account_id_asset_id_addresses_address_id_set_customer_ref_id_post(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostError>>;
    async fn vault_accounts_vault_account_id_asset_id_addresses_get(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesGetParams ) -> Result<Vec<models::VaultWalletAddress>, Error<VaultAccountsVaultAccountIdAssetIdAddressesGetError>>;
    async fn vault_accounts_vault_account_id_asset_id_addresses_paginated_get(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetParams ) -> Result<models::AddressesResponse, Error<VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetError>>;
    async fn vault_accounts_vault_account_id_asset_id_balance_post(&self,  params: VaultAccountsVaultAccountIdAssetIdBalancePostParams ) -> Result<models::VaultAsset, Error<VaultAccountsVaultAccountIdAssetIdBalancePostError>>;
    async fn vault_accounts_vault_account_id_asset_id_change_address_index_public_key_info_get(&self,  params: VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetParams ) -> Result<models::PublicKeyInformation, Error<VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetError>>;
    async fn vault_accounts_vault_account_id_asset_id_get(&self,  params: VaultAccountsVaultAccountIdAssetIdGetParams ) -> Result<models::VaultAsset, Error<VaultAccountsVaultAccountIdAssetIdGetError>>;
    async fn vault_accounts_vault_account_id_asset_id_max_spendable_amount_get(&self,  params: VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetParams ) -> Result<(), Error<VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetError>>;
    async fn vault_accounts_vault_account_id_asset_id_post(&self,  params: VaultAccountsVaultAccountIdAssetIdPostParams ) -> Result<models::CreateVaultAssetResponse, Error<VaultAccountsVaultAccountIdAssetIdPostError>>;
    async fn vault_accounts_vault_account_id_asset_id_unspent_inputs_get(&self,  params: VaultAccountsVaultAccountIdAssetIdUnspentInputsGetParams ) -> Result<Vec<models::UnspentInputsResponse>, Error<VaultAccountsVaultAccountIdAssetIdUnspentInputsGetError>>;
    async fn vault_accounts_vault_account_id_get(&self,  params: VaultAccountsVaultAccountIdGetParams ) -> Result<models::VaultAccount, Error<VaultAccountsVaultAccountIdGetError>>;
    async fn vault_accounts_vault_account_id_hide_post(&self,  params: VaultAccountsVaultAccountIdHidePostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdHidePostError>>;
    async fn vault_accounts_vault_account_id_put(&self,  params: VaultAccountsVaultAccountIdPutParams ) -> Result<(), Error<VaultAccountsVaultAccountIdPutError>>;
    async fn vault_accounts_vault_account_id_set_auto_fuel_post(&self,  params: VaultAccountsVaultAccountIdSetAutoFuelPostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdSetAutoFuelPostError>>;
    async fn vault_accounts_vault_account_id_set_customer_ref_id_post(&self,  params: VaultAccountsVaultAccountIdSetCustomerRefIdPostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdSetCustomerRefIdPostError>>;
    async fn vault_accounts_vault_account_id_unhide_post(&self,  params: VaultAccountsVaultAccountIdUnhidePostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdUnhidePostError>>;
    async fn vault_asset_wallets_get(&self,  params: VaultAssetWalletsGetParams ) -> Result<models::PaginatedAssetWalletResponse, Error<VaultAssetWalletsGetError>>;
    async fn vault_assets_asset_id_get(&self,  params: VaultAssetsAssetIdGetParams ) -> Result<models::VaultAsset, Error<VaultAssetsAssetIdGetError>>;
    async fn vault_assets_get(&self,  params: VaultAssetsGetParams ) -> Result<Vec<models::VaultAsset>, Error<VaultAssetsGetError>>;
    async fn vault_public_key_info_get(&self,  params: VaultPublicKeyInfoGetParams ) -> Result<models::PublicKeyInformation, Error<VaultPublicKeyInfoGetError>>;
}

pub struct VaultsApiClient {
    configuration: Arc<configuration::Configuration>
}

impl VaultsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`create_vault_account_asset_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateVaultAccountAssetAddressParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    pub create_vault_account_asset_address_request: Option<models::CreateVaultAccountAssetAddressRequest>
}

/// struct for passing parameters to the method [`vault_accounts_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsGetParams {
    pub name_prefix: Option<String>,
    pub name_suffix: Option<String>,
    pub min_amount_threshold: Option<f64>,
    pub asset_id: Option<String>
}

/// struct for passing parameters to the method [`vault_accounts_paged_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsPagedGetParams {
    pub name_prefix: Option<String>,
    pub name_suffix: Option<String>,
    /// Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts.
    pub min_amount_threshold: Option<f64>,
    pub asset_id: Option<String>,
    pub order_by: Option<String>,
    pub before: Option<String>,
    pub after: Option<String>,
    pub limit: Option<f64>
}

/// struct for passing parameters to the method [`vault_accounts_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsPostParams {
    pub vault_accounts_post_request: models::VaultAccountsPostRequest
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_activate_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdActivatePostParams {
    /// The ID of the vault account to return, or 'default' for the default vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_addresses_address_id_create_legacy_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// The segwit address to translate
    pub address_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_addresses_address_id_put`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address
    pub address_id: String,
    pub vault_accounts_vault_account_id_asset_id_addresses_address_id_put_request: Option<models::VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutRequest>
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_addresses_address_id_set_customer_ref_id_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address
    pub address_id: String,
    pub vault_accounts_vault_account_id_set_customer_ref_id_post_request: models::VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_addresses_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdAddressesGetParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_addresses_paginated_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetParams {
    pub vault_account_id: String,
    pub asset_id: String,
    pub limit: Option<f64>,
    pub before: Option<String>,
    pub after: Option<String>
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_balance_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdBalancePostParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_change_address_index_public_key_info_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset.
    pub asset_id: String,
    /// Whether the address should be derived internal (change) or not.
    pub change: f64,
    /// The index of the address for the derivation path.
    pub address_index: f64,
    pub compressed: Option<bool>
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdGetParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_max_spendable_amount_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetParams {
    /// The ID of the vault account, or 'default' for the default vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
    pub manual_signging: Option<bool>
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdPostParams {
    /// The ID of the vault account to return, or 'default' for the default vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    pub vault_accounts_vault_account_id_asset_id_post_request: Option<models::VaultAccountsVaultAccountIdAssetIdPostRequest>
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_asset_id_unspent_inputs_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdAssetIdUnspentInputsGetParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdGetParams {
    /// The ID of the vault account to return type: string
    pub vault_account_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_hide_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdHidePostParams {
    /// The vault account to hide
    pub vault_account_id: String
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_put`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdPutParams {
    /// The ID of the vault account to edit
    pub vault_account_id: String,
    pub vault_accounts_vault_account_id_put_request: models::VaultAccountsVaultAccountIdPutRequest
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_set_auto_fuel_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdSetAutoFuelPostParams {
    /// The vault account ID
    pub vault_account_id: String,
    pub vault_accounts_vault_account_id_set_auto_fuel_post_request: models::VaultAccountsVaultAccountIdSetAutoFuelPostRequest
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_set_customer_ref_id_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdSetCustomerRefIdPostParams {
    /// The vault account ID
    pub vault_account_id: String,
    pub vault_accounts_vault_account_id_set_customer_ref_id_post_request: models::VaultAccountsVaultAccountIdSetCustomerRefIdPostRequest
}

/// struct for passing parameters to the method [`vault_accounts_vault_account_id_unhide_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAccountsVaultAccountIdUnhidePostParams {
    /// The vault account to unhide
    pub vault_account_id: String
}

/// struct for passing parameters to the method [`vault_asset_wallets_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAssetWalletsGetParams {
    /// When specified, only asset wallets with total balance larger than this amount are returned.
    pub total_amount_larger_than: Option<f64>,
    /// When specified, only asset wallets cross vault accounts that have this asset ID are returned.
    pub asset_id: Option<String>,
    pub order_by: Option<String>,
    /// Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
    pub before: Option<String>,
    /// Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
    pub after: Option<String>,
    /// The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
    pub limit: Option<f64>
}

/// struct for passing parameters to the method [`vault_assets_asset_id_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAssetsAssetIdGetParams {
    pub asset_id: String
}

/// struct for passing parameters to the method [`vault_assets_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultAssetsGetParams {
    pub account_name_prefix: Option<String>,
    pub account_name_suffix: Option<String>
}

/// struct for passing parameters to the method [`vault_public_key_info_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct VaultPublicKeyInfoGetParams {
    /// An array of integers representing the full BIP44 derivation path of the requested public key.  The first element must always be 44. 
    pub derivation_path: Vec<i32>,
    pub algorithm: String,
    pub compressed: Option<bool>
}


#[async_trait]
impl VaultsApi for VaultsApiClient {
    /// Creates a new deposit address for an asset of a vault account.
    async fn create_vault_account_asset_address(&self,  params: CreateVaultAccountAssetAddressParams ) -> Result<models::CreateAddressResponse, Error<CreateVaultAccountAssetAddressError>> {
        
        let CreateVaultAccountAssetAddressParams {
            vault_account_id,
            asset_id,
            create_vault_account_asset_address_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/addresses", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&create_vault_account_asset_address_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<CreateVaultAccountAssetAddressError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets all vault accounts in your workspace.
    async fn vault_accounts_get(&self,  params: VaultAccountsGetParams ) -> Result<Vec<models::VaultAccount>, Error<VaultAccountsGetError>> {
        
        let VaultAccountsGetParams {
            name_prefix,
            name_suffix,
            min_amount_threshold,
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = name_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("namePrefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = name_suffix {
            local_var_req_builder = local_var_req_builder.query(&[("nameSuffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_amount_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("minAmountThreshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = asset_id {
            local_var_req_builder = local_var_req_builder.query(&[("assetId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
    async fn vault_accounts_paged_get(&self,  params: VaultAccountsPagedGetParams ) -> Result<models::VaultAccountsPagedResponse, Error<VaultAccountsPagedGetError>> {
        
        let VaultAccountsPagedGetParams {
            name_prefix,
            name_suffix,
            min_amount_threshold,
            asset_id,
            order_by,
            before,
            after,
            limit,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts_paged", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = name_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("namePrefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = name_suffix {
            local_var_req_builder = local_var_req_builder.query(&[("nameSuffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_amount_threshold {
            local_var_req_builder = local_var_req_builder.query(&[("minAmountThreshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = asset_id {
            local_var_req_builder = local_var_req_builder.query(&[("assetId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = order_by {
            local_var_req_builder = local_var_req_builder.query(&[("orderBy", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = before {
            local_var_req_builder = local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder = local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsPagedGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a new vault account with the requested name.
    async fn vault_accounts_post(&self,  params: VaultAccountsPostParams ) -> Result<models::VaultAccount, Error<VaultAccountsPostError>> {
        
        let VaultAccountsPostParams {
            vault_accounts_post_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_post_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Initiates activation for a wallet in a vault account. Activation is required for tokens that need an on-chain transaction for creation (XLM tokens, SOL tokens etc).
    async fn vault_accounts_vault_account_id_asset_id_activate_post(&self,  params: VaultAccountsVaultAccountIdAssetIdActivatePostParams ) -> Result<models::CreateVaultAssetResponse, Error<VaultAccountsVaultAccountIdAssetIdActivatePostError>> {
        
        let VaultAccountsVaultAccountIdAssetIdActivatePostParams {
            vault_account_id,
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/activate", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdActivatePostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Converts an existing segwit address to the legacy format.
    async fn vault_accounts_vault_account_id_asset_id_addresses_address_id_create_legacy_post(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostParams ) -> Result<models::CreateAddressResponse, Error<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostError>> {
        
        let VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostParams {
            vault_account_id,
            asset_id,
            address_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id), addressId=crate::apis::urlencode(address_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates the description of an existing address of an asset in a vault account.
    async fn vault_accounts_vault_account_id_asset_id_addresses_address_id_put(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutParams ) -> Result<(), Error<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutError>> {
        
        let VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutParams {
            vault_account_id,
            asset_id,
            address_id,
            vault_accounts_vault_account_id_asset_id_addresses_address_id_put_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id), addressId=crate::apis::urlencode(address_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_vault_account_id_asset_id_addresses_address_id_put_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Sets an AML/KYT customer reference ID for a specific address.
    async fn vault_accounts_vault_account_id_asset_id_addresses_address_id_set_customer_ref_id_post(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostError>> {
        
        let VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostParams {
            vault_account_id,
            asset_id,
            address_id,
            vault_accounts_vault_account_id_set_customer_ref_id_post_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id), addressId=crate::apis::urlencode(address_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_vault_account_id_set_customer_ref_id_post_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Lists all addresses for specific asset of vault account. </br> - **This endpoint will be deprecated on Mar 31, 2024.** - If your application logic or scripts rely on the deprecated endpoint, you should update to account for `GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated` before Mar 31, 2024. - All workspaces created after Mar 31, 2024. will have it disabled. If it is disabled for your workspace and you attempt to use it, you will receive the following error message: 'This endpoint is unavailable.' - Please use the `GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated endpoint` to return all the wallet addresses associated with the specified vault account and asset in a paginated list. - This API call is subject to rate limits.
    async fn vault_accounts_vault_account_id_asset_id_addresses_get(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesGetParams ) -> Result<Vec<models::VaultWalletAddress>, Error<VaultAccountsVaultAccountIdAssetIdAddressesGetError>> {
        
        let VaultAccountsVaultAccountIdAssetIdAddressesGetParams {
            vault_account_id,
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/addresses", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdAddressesGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a paginated response of the addresses for a given vault account and asset.
    async fn vault_accounts_vault_account_id_asset_id_addresses_paginated_get(&self,  params: VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetParams ) -> Result<models::AddressesResponse, Error<VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetError>> {
        
        let VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetParams {
            vault_account_id,
            asset_id,
            limit,
            before,
            after,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = limit {
            local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = before {
            local_var_req_builder = local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder = local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates the balance of a specific asset in a vault account.
    async fn vault_accounts_vault_account_id_asset_id_balance_post(&self,  params: VaultAccountsVaultAccountIdAssetIdBalancePostParams ) -> Result<models::VaultAsset, Error<VaultAccountsVaultAccountIdAssetIdBalancePostError>> {
        
        let VaultAccountsVaultAccountIdAssetIdBalancePostParams {
            vault_account_id,
            asset_id,
            body,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/balance", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdBalancePostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets the public key information for the vault account.
    async fn vault_accounts_vault_account_id_asset_id_change_address_index_public_key_info_get(&self,  params: VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetParams ) -> Result<models::PublicKeyInformation, Error<VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetError>> {
        
        let VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetParams {
            vault_account_id,
            asset_id,
            change,
            address_index,
            compressed,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id), change=change, addressIndex=address_index);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = compressed {
            local_var_req_builder = local_var_req_builder.query(&[("compressed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a wallet for a specific asset of a vault account.
    async fn vault_accounts_vault_account_id_asset_id_get(&self,  params: VaultAccountsVaultAccountIdAssetIdGetParams ) -> Result<models::VaultAsset, Error<VaultAccountsVaultAccountIdAssetIdGetError>> {
        
        let VaultAccountsVaultAccountIdAssetIdGetParams {
            vault_account_id,
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
    async fn vault_accounts_vault_account_id_asset_id_max_spendable_amount_get(&self,  params: VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetParams ) -> Result<(), Error<VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetError>> {
        
        let VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetParams {
            vault_account_id,
            asset_id,
            manual_signging,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = manual_signging {
            local_var_req_builder = local_var_req_builder.query(&[("manualSignging", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a wallet for a specific asset in a vault account.
    async fn vault_accounts_vault_account_id_asset_id_post(&self,  params: VaultAccountsVaultAccountIdAssetIdPostParams ) -> Result<models::CreateVaultAssetResponse, Error<VaultAccountsVaultAccountIdAssetIdPostError>> {
        
        let VaultAccountsVaultAccountIdAssetIdPostParams {
            vault_account_id,
            asset_id,
            vault_accounts_vault_account_id_asset_id_post_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_vault_account_id_asset_id_post_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns unspent inputs information of an asset in a vault account.
    async fn vault_accounts_vault_account_id_asset_id_unspent_inputs_get(&self,  params: VaultAccountsVaultAccountIdAssetIdUnspentInputsGetParams ) -> Result<Vec<models::UnspentInputsResponse>, Error<VaultAccountsVaultAccountIdAssetIdUnspentInputsGetError>> {
        
        let VaultAccountsVaultAccountIdAssetIdUnspentInputsGetParams {
            vault_account_id,
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id), assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdAssetIdUnspentInputsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns the requested vault account.
    async fn vault_accounts_vault_account_id_get(&self,  params: VaultAccountsVaultAccountIdGetParams ) -> Result<models::VaultAccount, Error<VaultAccountsVaultAccountIdGetError>> {
        
        let VaultAccountsVaultAccountIdGetParams {
            vault_account_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Hides the requested vault account from the web console view.
    async fn vault_accounts_vault_account_id_hide_post(&self,  params: VaultAccountsVaultAccountIdHidePostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdHidePostError>> {
        
        let VaultAccountsVaultAccountIdHidePostParams {
            vault_account_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/hide", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdHidePostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Renames the requested vault account.
    async fn vault_accounts_vault_account_id_put(&self,  params: VaultAccountsVaultAccountIdPutParams ) -> Result<(), Error<VaultAccountsVaultAccountIdPutError>> {
        
        let VaultAccountsVaultAccountIdPutParams {
            vault_account_id,
            vault_accounts_vault_account_id_put_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_vault_account_id_put_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdPutError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Sets the autofueling property of the vault account to enabled or disabled.
    async fn vault_accounts_vault_account_id_set_auto_fuel_post(&self,  params: VaultAccountsVaultAccountIdSetAutoFuelPostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdSetAutoFuelPostError>> {
        
        let VaultAccountsVaultAccountIdSetAutoFuelPostParams {
            vault_account_id,
            vault_accounts_vault_account_id_set_auto_fuel_post_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/set_auto_fuel", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_vault_account_id_set_auto_fuel_post_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdSetAutoFuelPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Assigns an AML/KYT customer reference ID for the vault account.
    async fn vault_accounts_vault_account_id_set_customer_ref_id_post(&self,  params: VaultAccountsVaultAccountIdSetCustomerRefIdPostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdSetCustomerRefIdPostError>> {
        
        let VaultAccountsVaultAccountIdSetCustomerRefIdPostParams {
            vault_account_id,
            vault_accounts_vault_account_id_set_customer_ref_id_post_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/set_customer_ref_id", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&vault_accounts_vault_account_id_set_customer_ref_id_post_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdSetCustomerRefIdPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Makes a hidden vault account visible in web console view.
    async fn vault_accounts_vault_account_id_unhide_post(&self,  params: VaultAccountsVaultAccountIdUnhidePostParams ) -> Result<(), Error<VaultAccountsVaultAccountIdUnhidePostError>> {
        
        let VaultAccountsVaultAccountIdUnhidePostParams {
            vault_account_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts/{vaultAccountId}/unhide", local_var_configuration.base_path, vaultAccountId=crate::apis::urlencode(vault_account_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<VaultAccountsVaultAccountIdUnhidePostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting). 
    async fn vault_asset_wallets_get(&self,  params: VaultAssetWalletsGetParams ) -> Result<models::PaginatedAssetWalletResponse, Error<VaultAssetWalletsGetError>> {
        
        let VaultAssetWalletsGetParams {
            total_amount_larger_than,
            asset_id,
            order_by,
            before,
            after,
            limit,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/asset_wallets", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = total_amount_larger_than {
            local_var_req_builder = local_var_req_builder.query(&[("totalAmountLargerThan", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = asset_id {
            local_var_req_builder = local_var_req_builder.query(&[("assetId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = order_by {
            local_var_req_builder = local_var_req_builder.query(&[("orderBy", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = before {
            local_var_req_builder = local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder = local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAssetWalletsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets the vault balance summary for an asset.
    async fn vault_assets_asset_id_get(&self,  params: VaultAssetsAssetIdGetParams ) -> Result<models::VaultAsset, Error<VaultAssetsAssetIdGetError>> {
        
        let VaultAssetsAssetIdGetParams {
            asset_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/assets/{assetId}", local_var_configuration.base_path, assetId=crate::apis::urlencode(asset_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAssetsAssetIdGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets the assets amount summary for all accounts or filtered accounts.
    async fn vault_assets_get(&self,  params: VaultAssetsGetParams ) -> Result<Vec<models::VaultAsset>, Error<VaultAssetsGetError>> {
        
        let VaultAssetsGetParams {
            account_name_prefix,
            account_name_suffix,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/assets", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = account_name_prefix {
            local_var_req_builder = local_var_req_builder.query(&[("accountNamePrefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = account_name_suffix {
            local_var_req_builder = local_var_req_builder.query(&[("accountNameSuffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultAssetsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets the public key information based on derivation path and signing algorithm.
    async fn vault_public_key_info_get(&self,  params: VaultPublicKeyInfoGetParams ) -> Result<models::PublicKeyInformation, Error<VaultPublicKeyInfoGetError>> {
        
        let VaultPublicKeyInfoGetParams {
            derivation_path,
            algorithm,
            compressed,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/public_key_info/", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&derivation_path.into_iter().map(|p| ("derivationPath".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("derivationPath", &derivation_path.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
        local_var_req_builder = local_var_req_builder.query(&[("algorithm", &algorithm.to_string())]);
        if let Some(ref local_var_str) = compressed {
            local_var_req_builder = local_var_req_builder.query(&[("compressed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<VaultPublicKeyInfoGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`create_vault_account_asset_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVaultAccountAssetAddressError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_paged_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsPagedGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_activate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdActivatePostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_addresses_address_id_create_legacy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdAddressesAddressIdCreateLegacyPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_addresses_address_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdAddressesAddressIdPutError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_addresses_address_id_set_customer_ref_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdAddressesAddressIdSetCustomerRefIdPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_addresses_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdAddressesGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_addresses_paginated_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdAddressesPaginatedGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_balance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdBalancePostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_change_address_index_public_key_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdChangeAddressIndexPublicKeyInfoGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_max_spendable_amount_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdMaxSpendableAmountGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_asset_id_unspent_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdAssetIdUnspentInputsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_hide_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdHidePostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdPutError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_set_auto_fuel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdSetAutoFuelPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_set_customer_ref_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdSetCustomerRefIdPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_accounts_vault_account_id_unhide_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAccountsVaultAccountIdUnhidePostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_asset_wallets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAssetWalletsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_assets_asset_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAssetsAssetIdGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_assets_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultAssetsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vault_public_key_info_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VaultPublicKeyInfoGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

