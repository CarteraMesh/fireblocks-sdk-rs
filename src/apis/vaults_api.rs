// Fireblocks API
//
// Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com)
//
// The version of the OpenAPI document: 1.8.0
// Contact: developers@fireblocks.com
// Generated by: https://openapi-generator.tech

use {
    super::{configuration, Error},
    crate::{
        apis::{ContentType, ResponseContent},
        models,
    },
    async_trait::async_trait,
    reqwest,
    serde::{de::Error as _, Deserialize, Serialize},
    std::sync::Arc,
};

#[async_trait]
pub trait VaultsApi: Send + Sync {
    /// POST /vault/accounts/{vaultAccountId}/{assetId}/activate
    ///
    /// Initiates activation for a wallet in a vault account.  Activation is
    /// required for tokens that need an on-chain transaction for creation (XLM
    /// tokens, SOL tokens etc). </br>Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor.
    async fn activate_asset_for_vault_account(
        &self,
        params: ActivateAssetForVaultAccountParams,
    ) -> Result<models::CreateVaultAssetResponse, Error<ActivateAssetForVaultAccountError>>;

    /// POST /vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/
    /// create_legacy
    ///
    /// Converts an existing segwit address to the legacy format. </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_legacy_address(
        &self,
        params: CreateLegacyAddressParams,
    ) -> Result<models::CreateAddressResponse, Error<CreateLegacyAddressError>>;

    /// POST /vault/accounts/addresses/bulk
    ///
    /// Create multiple deposit address by running an async job. </br> **Note**:
    /// - We limit accounts to 10k per operation. - The target Vault Account
    /// should already have the asset wallet created, or the deposit addresses
    /// will fail. - This endpoint should be used for UTXO blockchains. - This
    /// endpoint is currently in Early Availability. Please contact CSM to get
    /// access to this endpoint.   Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor.
    async fn create_multiple_deposit_addresses(
        &self,
        params: CreateMultipleDepositAddressesParams,
    ) -> Result<models::JobCreated, Error<CreateMultipleDepositAddressesError>>;

    /// POST /vault/accounts
    ///
    /// Creates a new vault account with the requested name. **Note: ** Vault account names should consist of ASCII characters only. Learn more about Fireblocks Vault Accounts in the following [guide](https://developers.fireblocks.com/reference/create-vault-account). </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_vault_account(
        &self,
        params: CreateVaultAccountParams,
    ) -> Result<models::VaultAccount, Error<CreateVaultAccountError>>;

    /// POST /vault/accounts/{vaultAccountId}/{assetId}
    ///
    /// Creates a wallet for a specific asset in a vault account. Learn more about Fireblocks Vault Wallets in the following [guide](https://developers.fireblocks.com/reference/create-vault-wallet). </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_vault_account_asset(
        &self,
        params: CreateVaultAccountAssetParams,
    ) -> Result<models::CreateVaultAssetResponse, Error<CreateVaultAccountAssetError>>;

    /// POST /vault/accounts/{vaultAccountId}/{assetId}/addresses
    ///
    /// Creates a new deposit address for an asset of a vault account. Should be
    /// used for UTXO or Tag/Memo based assets ONLY.  Requests with account
    /// based assets will fail.  </br>Endpoint Permission: Admin, Non-Signing
    /// Admin.
    async fn create_vault_account_asset_address(
        &self,
        params: CreateVaultAccountAssetAddressParams,
    ) -> Result<models::CreateAddressResponse, Error<CreateVaultAccountAssetAddressError>>;

    /// GET /vault/asset_wallets
    ///
    /// Get all vault wallets of the vault accounts in your workspace.  A vault
    /// wallet is an asset in a vault account.   This method allows fast
    /// traversal of all account balances. </br>Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_asset_wallets(
        &self,
        params: GetAssetWalletsParams,
    ) -> Result<models::PaginatedAssetWalletResponse, Error<GetAssetWalletsError>>;

    /// GET /vault/accounts/addresses/bulk/{jobId}
    ///
    /// Returns the status of the bulk creation of new deposit addresses job,
    /// and the result or error. **Note**: - The target Vault Account should
    /// already have the asset wallet created, or the deposit addresses will
    /// fail. - This endpoint is currently in Early Availability. Please contact
    /// CSM to get access to this endpoint. Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver, Editor.
    async fn get_create_multiple_deposit_addresses_job_status(
        &self,
        params: GetCreateMultipleDepositAddressesJobStatusParams,
    ) -> Result<
        models::CreateMultipleDepositAddressesJobStatus,
        Error<GetCreateMultipleDepositAddressesJobStatusError>,
    >;

    /// GET /vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount
    ///
    /// Get the maximum amount of a particular asset that can be spent in a
    /// single transaction from a specified vault account (UTXO assets only).
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_max_spendable_amount(
        &self,
        params: GetMaxSpendableAmountParams,
    ) -> Result<models::GetMaxSpendableAmountResponse, Error<GetMaxSpendableAmountError>>;

    /// GET /vault/accounts_paged
    ///
    /// Gets all vault accounts in your workspace. This endpoint returns a
    /// limited amount of results with a quick response time. </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_paged_vault_accounts(
        &self,
        params: GetPagedVaultAccountsParams,
    ) -> Result<models::VaultAccountsPagedResponse, Error<GetPagedVaultAccountsError>>;

    /// GET /vault/public_key_info
    ///
    /// Gets the public key information based on derivation path and signing
    /// algorithm. </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn get_public_key_info(
        &self,
        params: GetPublicKeyInfoParams,
    ) -> Result<models::PublicKeyInformation, Error<GetPublicKeyInfoError>>;

    /// GET /vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/
    /// public_key_info
    ///
    /// Get the public key information for a specific asset in a vault account.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn get_public_key_info_for_address(
        &self,
        params: GetPublicKeyInfoForAddressParams,
    ) -> Result<models::PublicKeyInformation, Error<GetPublicKeyInfoForAddressError>>;

    /// GET /vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs
    ///
    /// Returns unspent inputs information of an UTXO asset in a vault account.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_unspent_inputs(
        &self,
        params: GetUnspentInputsParams,
    ) -> Result<Vec<models::UnspentInputsResponse>, Error<GetUnspentInputsError>>;

    /// GET /vault/accounts/{vaultAccountId}
    ///
    /// Get a vault account by its unique ID. </br>Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_vault_account(
        &self,
        params: GetVaultAccountParams,
    ) -> Result<models::VaultAccount, Error<GetVaultAccountError>>;

    /// GET /vault/accounts/{vaultAccountId}/{assetId}
    ///
    /// Returns a specific vault wallet balance information for a specific
    /// asset.  </br>Endpoint Permission: Admin, Non-Signing Admin, Signer,
    /// Approver, Editor,   Viewer.
    async fn get_vault_account_asset(
        &self,
        params: GetVaultAccountAssetParams,
    ) -> Result<models::VaultAsset, Error<GetVaultAccountAssetError>>;

    /// GET /vault/accounts/{vaultAccountId}/{assetId}/addresses
    ///
    /// DEPRECATED!  - If your application logic or scripts rely on the
    /// deprecated endpoint, you should update to account for
    /// GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated
    /// before Mar 31,2024. - All workspaces created after Mar 31,2024. will
    /// have it disabled. If it is disabled for your workspace and you attempt
    /// to use it, you will receive the following error message: \"This endpoint
    /// is unavailable. - Please use the GET
    /// /v1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated
    /// endpoint to return all the wallet addresses associated with the
    /// specified vault account and asset in a paginated list.  </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_vault_account_asset_addresses(
        &self,
        params: GetVaultAccountAssetAddressesParams,
    ) -> Result<Vec<models::VaultWalletAddress>, Error<GetVaultAccountAssetAddressesError>>;

    /// GET /vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated
    ///
    /// Returns a paginated response of the addresses for a given vault account
    /// and asset. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer,
    /// Approver, Editor, Viewer.
    async fn get_vault_account_asset_addresses_paginated(
        &self,
        params: GetVaultAccountAssetAddressesPaginatedParams,
    ) -> Result<models::PaginatedAddressResponse, Error<GetVaultAccountAssetAddressesPaginatedError>>;

    /// GET /vault/assets
    ///
    /// Gets the assets amount summary for all accounts or filtered accounts.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_vault_assets(
        &self,
        params: GetVaultAssetsParams,
    ) -> Result<Vec<models::VaultAsset>, Error<GetVaultAssetsError>>;

    /// GET /vault/assets/{assetId}
    ///
    /// Get the total balance of an asset across all the vault accounts.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_vault_balance_by_asset(
        &self,
        params: GetVaultBalanceByAssetParams,
    ) -> Result<models::VaultAsset, Error<GetVaultBalanceByAssetError>>;

    /// POST /vault/accounts/{vaultAccountId}/hide
    ///
    /// Hides the requested vault account from the web console view. This operation is required when creating thousands of vault accounts to serve your end-users. Used for preventing the web console to be swamped with too much vault accounts. Learn more in the following [guide](https://developers.fireblocks.com/docs/create-direct-custody-wallets#hiding-vault-accounts). NOTE: Hiding the vault account from the web console will also hide all the related transactions to/from this vault. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn hide_vault_account(
        &self,
        params: HideVaultAccountParams,
    ) -> Result<models::VaultActionStatus, Error<HideVaultAccountError>>;

    /// POST /vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/
    /// set_customer_ref_id
    ///
    /// Sets an AML/KYT customer reference ID for a specific address.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn set_customer_ref_id_for_address(
        &self,
        params: SetCustomerRefIdForAddressParams,
    ) -> Result<models::VaultActionStatus, Error<SetCustomerRefIdForAddressError>>;

    /// POST /vault/accounts/{vaultAccountId}/set_auto_fuel
    ///
    /// Toggles the auto fueling property of the vault account to enabled or disabled. Vault Accounts with 'autoFuel=true' are monitored and auto fueled by the Fireblocks Gas Station. Learn more about the Fireblocks Gas Station in the following [guide](https://developers.fireblocks.com/docs/work-with-gas-station). </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn set_vault_account_auto_fuel(
        &self,
        params: SetVaultAccountAutoFuelParams,
    ) -> Result<models::VaultActionStatus, Error<SetVaultAccountAutoFuelError>>;

    /// POST /vault/accounts/{vaultAccountId}/set_customer_ref_id
    ///
    /// Assigns an AML/KYT customer reference ID for the vault account. Learn more about Fireblocks AML management in the following [guide](https://developers.fireblocks.com/docs/define-aml-policies). </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn set_vault_account_customer_ref_id(
        &self,
        params: SetVaultAccountCustomerRefIdParams,
    ) -> Result<models::VaultActionStatus, Error<SetVaultAccountCustomerRefIdError>>;

    /// POST /vault/accounts/{vaultAccountId}/unhide
    ///
    /// Makes a hidden vault account visible in web console view. </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn unhide_vault_account(
        &self,
        params: UnhideVaultAccountParams,
    ) -> Result<models::VaultActionStatus, Error<UnhideVaultAccountError>>;

    /// PUT /vault/accounts/{vaultAccountId}
    ///
    /// Renames the requested vault account. </br>Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver.
    async fn update_vault_account(
        &self,
        params: UpdateVaultAccountParams,
    ) -> Result<models::RenameVaultAccountResponse, Error<UpdateVaultAccountError>>;

    /// PUT /vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}
    ///
    /// Updates the description of an existing address of an asset in a vault
    /// account. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer,
    /// Approver, Editor.
    async fn update_vault_account_asset_address(
        &self,
        params: UpdateVaultAccountAssetAddressParams,
    ) -> Result<models::VaultActionStatus, Error<UpdateVaultAccountAssetAddressError>>;

    /// POST /vault/accounts/{vaultAccountId}/{assetId}/balance
    ///
    /// Updates the balance of a specific asset in a vault account.  This API
    /// endpoint is subject to a strict rate limit. Should be used by clients in
    /// very specific scenarios.  </br>Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor.
    async fn update_vault_account_asset_balance(
        &self,
        params: UpdateVaultAccountAssetBalanceParams,
    ) -> Result<models::VaultAsset, Error<UpdateVaultAccountAssetBalanceError>>;
}

pub struct VaultsApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl VaultsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

/// struct for passing parameters to the method
/// [`activate_asset_for_vault_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ActivateAssetForVaultAccountParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`create_legacy_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateLegacyAddressParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// The segwit address to translate
    pub address_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method
/// [`create_multiple_deposit_addresses`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateMultipleDepositAddressesParams {
    pub create_multiple_deposit_addresses_request: models::CreateMultipleDepositAddressesRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`create_vault_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateVaultAccountParams {
    pub create_vault_account_request: models::CreateVaultAccountRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`create_vault_account_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateVaultAccountAssetParams {
    /// The ID of the vault account to return, or 'default' for the default
    /// vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
    pub create_assets_request: Option<models::CreateAssetsRequest>,
}

/// struct for passing parameters to the method
/// [`create_vault_account_asset_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct CreateVaultAccountAssetAddressParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
    pub create_address_request: Option<models::CreateAddressRequest>,
}

/// struct for passing parameters to the method [`get_asset_wallets`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetAssetWalletsParams {
    /// When specified, only vault wallets with total balance greater than this
    /// amount are returned.
    pub total_amount_larger_than: Option<f64>,
    /// When specified, only vault wallets with the specified ID are returned.
    pub asset_id: Option<String>,
    pub order_by: Option<String>,
    /// Fetches the next paginated response before this element.  This element
    /// is a cursor and is returned at the response of the previous page.
    pub before: Option<String>,
    /// Fetches the next paginated response after this element. This element is
    /// a cursor and is returned at the response of the previous page.
    pub after: Option<String>,
    /// The maximum number of vault wallets in a single response.   The default
    /// is 200 and the maximum is 1000.
    pub limit: Option<f64>,
}

/// struct for passing parameters to the method
/// [`get_create_multiple_deposit_addresses_job_status`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetCreateMultipleDepositAddressesJobStatusParams {
    /// The ID of the job to create addresses
    pub job_id: String,
}

/// struct for passing parameters to the method [`get_max_spendable_amount`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetMaxSpendableAmountParams {
    /// The ID of the vault account, or 'default' for the default vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// False by default. The maximum number of inputs depends if the
    /// transaction will be signed by an automated co-signer server or on a
    /// mobile device.
    pub manual_signging: Option<bool>,
}

/// struct for passing parameters to the method [`get_paged_vault_accounts`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPagedVaultAccountsParams {
    pub name_prefix: Option<String>,
    pub name_suffix: Option<String>,
    /// Specifying minAmountThreshold will filter accounts with balances greater
    /// than this value, otherwise, it will return all accounts. The amount set
    /// in this parameter is the native asset amount and not its USD value.
    pub min_amount_threshold: Option<f64>,
    pub asset_id: Option<String>,
    pub order_by: Option<String>,
    pub before: Option<String>,
    pub after: Option<String>,
    pub limit: Option<f64>,
}

/// struct for passing parameters to the method [`get_public_key_info`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPublicKeyInfoParams {
    /// An array of integers representing the full BIP44 derivation path of the
    /// requested public key.  The first element must always be 44.
    pub derivation_path: Vec<i32>,
    pub algorithm: String,
    pub compressed: Option<bool>,
}

/// struct for passing parameters to the method
/// [`get_public_key_info_for_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPublicKeyInfoForAddressParams {
    pub vault_account_id: String,
    pub asset_id: String,
    /// BIP44 derivation path - change value
    pub change: f64,
    /// BIP44 derivation path - index value
    pub address_index: f64,
    /// Compressed/Uncompressed public key format
    pub compressed: Option<bool>,
}

/// struct for passing parameters to the method [`get_unspent_inputs`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetUnspentInputsParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
}

/// struct for passing parameters to the method [`get_vault_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetVaultAccountParams {
    /// The ID of the vault account
    pub vault_account_id: String,
}

/// struct for passing parameters to the method [`get_vault_account_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetVaultAccountAssetParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
}

/// struct for passing parameters to the method
/// [`get_vault_account_asset_addresses`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetVaultAccountAssetAddressesParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
}

/// struct for passing parameters to the method
/// [`get_vault_account_asset_addresses_paginated`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetVaultAccountAssetAddressesPaginatedParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// Limit the number of results per page
    pub limit: Option<f64>,
    /// Cursor string for the previous page
    pub before: Option<String>,
    /// Cursor string for the next page
    pub after: Option<String>,
}

/// struct for passing parameters to the method [`get_vault_assets`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetVaultAssetsParams {
    pub account_name_prefix: Option<String>,
    pub account_name_suffix: Option<String>,
}

/// struct for passing parameters to the method [`get_vault_balance_by_asset`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetVaultBalanceByAssetParams {
    pub asset_id: String,
}

/// struct for passing parameters to the method [`hide_vault_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct HideVaultAccountParams {
    /// The vault account to hide
    pub vault_account_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method
/// [`set_customer_ref_id_for_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetCustomerRefIdForAddressParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// The address for which to add a description. For XRP, use
    /// <address>:<tag>, for all other assets, use only the address
    pub address_id: String,
    pub set_customer_ref_id_for_address_request: models::SetCustomerRefIdForAddressRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`set_vault_account_auto_fuel`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetVaultAccountAutoFuelParams {
    /// The vault account ID
    pub vault_account_id: String,
    pub set_auto_fuel_request: models::SetAutoFuelRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method
/// [`set_vault_account_customer_ref_id`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SetVaultAccountCustomerRefIdParams {
    /// The vault account ID
    pub vault_account_id: String,
    pub set_customer_ref_id_request: models::SetCustomerRefIdRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`unhide_vault_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UnhideVaultAccountParams {
    /// The vault account to unhide
    pub vault_account_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method [`update_vault_account`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateVaultAccountParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    pub update_vault_account_request: models::UpdateVaultAccountRequest,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

/// struct for passing parameters to the method
/// [`update_vault_account_asset_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateVaultAccountAssetAddressParams {
    /// The ID of the vault account
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// The address for which to add a description. For XRP, use
    /// <address>:<tag>, for all other assets, use only the address
    pub address_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
    pub update_vault_account_asset_address_request:
        Option<models::UpdateVaultAccountAssetAddressRequest>,
}

/// struct for passing parameters to the method
/// [`update_vault_account_asset_balance`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateVaultAccountAssetBalanceParams {
    /// The ID of the vault account to return
    pub vault_account_id: String,
    /// The ID of the asset
    pub asset_id: String,
    /// A unique identifier for the request. If the request is sent multiple
    /// times with the same idempotency key, the server will return the same
    /// response as the first request. The idempotency key is valid for 24
    /// hours.
    pub idempotency_key: Option<String>,
}

#[async_trait]
impl VaultsApi for VaultsApiClient {
    /// Initiates activation for a wallet in a vault account.  Activation is
    /// required for tokens that need an on-chain transaction for creation (XLM
    /// tokens, SOL tokens etc). </br>Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor.
    async fn activate_asset_for_vault_account(
        &self,
        params: ActivateAssetForVaultAccountParams,
    ) -> Result<models::CreateVaultAssetResponse, Error<ActivateAssetForVaultAccountError>> {
        let ActivateAssetForVaultAccountParams {
            vault_account_id,
            asset_id,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/activate",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::CreateVaultAssetResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::CreateVaultAssetResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<ActivateAssetForVaultAccountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Converts an existing segwit address to the legacy format. </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_legacy_address(
        &self,
        params: CreateLegacyAddressParams,
    ) -> Result<models::CreateAddressResponse, Error<CreateLegacyAddressError>> {
        let CreateLegacyAddressParams {
            vault_account_id,
            asset_id,
            address_id,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id),
            addressId = crate::apis::urlencode(address_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::CreateAddressResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::CreateAddressResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<CreateLegacyAddressError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Create multiple deposit address by running an async job. </br> **Note**:
    /// - We limit accounts to 10k per operation. - The target Vault Account
    /// should already have the asset wallet created, or the deposit addresses
    /// will fail. - This endpoint should be used for UTXO blockchains. - This
    /// endpoint is currently in Early Availability. Please contact CSM to get
    /// access to this endpoint.   Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor.
    async fn create_multiple_deposit_addresses(
        &self,
        params: CreateMultipleDepositAddressesParams,
    ) -> Result<models::JobCreated, Error<CreateMultipleDepositAddressesError>> {
        let CreateMultipleDepositAddressesParams {
            create_multiple_deposit_addresses_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/addresses/bulk",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder =
            local_var_req_builder.json(&create_multiple_deposit_addresses_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::JobCreated`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::JobCreated`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<CreateMultipleDepositAddressesError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a new vault account with the requested name. **Note: ** Vault account names should consist of ASCII characters only. Learn more about Fireblocks Vault Accounts in the following [guide](https://developers.fireblocks.com/reference/create-vault-account). </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_vault_account(
        &self,
        params: CreateVaultAccountParams,
    ) -> Result<models::VaultAccount, Error<CreateVaultAccountError>> {
        let CreateVaultAccountParams {
            create_vault_account_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/accounts", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&create_vault_account_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultAccount`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultAccount`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<CreateVaultAccountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a wallet for a specific asset in a vault account. Learn more about Fireblocks Vault Wallets in the following [guide](https://developers.fireblocks.com/reference/create-vault-wallet). </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn create_vault_account_asset(
        &self,
        params: CreateVaultAccountAssetParams,
    ) -> Result<models::CreateVaultAssetResponse, Error<CreateVaultAccountAssetError>> {
        let CreateVaultAccountAssetParams {
            vault_account_id,
            asset_id,
            idempotency_key,
            create_assets_request,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&create_assets_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::CreateVaultAssetResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::CreateVaultAssetResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<CreateVaultAccountAssetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a new deposit address for an asset of a vault account. Should be
    /// used for UTXO or Tag/Memo based assets ONLY.  Requests with account
    /// based assets will fail.  </br>Endpoint Permission: Admin, Non-Signing
    /// Admin.
    async fn create_vault_account_asset_address(
        &self,
        params: CreateVaultAccountAssetAddressParams,
    ) -> Result<models::CreateAddressResponse, Error<CreateVaultAccountAssetAddressError>> {
        let CreateVaultAccountAssetAddressParams {
            vault_account_id,
            asset_id,
            idempotency_key,
            create_address_request,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/addresses",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&create_address_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::CreateAddressResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::CreateAddressResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<CreateVaultAccountAssetAddressError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get all vault wallets of the vault accounts in your workspace.  A vault
    /// wallet is an asset in a vault account.   This method allows fast
    /// traversal of all account balances. </br>Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_asset_wallets(
        &self,
        params: GetAssetWalletsParams,
    ) -> Result<models::PaginatedAssetWalletResponse, Error<GetAssetWalletsError>> {
        let GetAssetWalletsParams {
            total_amount_larger_than,
            asset_id,
            order_by,
            before,
            after,
            limit,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str =
            format!("{}/vault/asset_wallets", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = total_amount_larger_than {
            local_var_req_builder = local_var_req_builder
                .query(&[("totalAmountLargerThan", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = asset_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("assetId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = order_by {
            local_var_req_builder =
                local_var_req_builder.query(&[("orderBy", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = before {
            local_var_req_builder =
                local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder =
                local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder =
                local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::PaginatedAssetWalletResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::PaginatedAssetWalletResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetAssetWalletsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns the status of the bulk creation of new deposit addresses job,
    /// and the result or error. **Note**: - The target Vault Account should
    /// already have the asset wallet created, or the deposit addresses will
    /// fail. - This endpoint is currently in Early Availability. Please contact
    /// CSM to get access to this endpoint. Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver, Editor.
    async fn get_create_multiple_deposit_addresses_job_status(
        &self,
        params: GetCreateMultipleDepositAddressesJobStatusParams,
    ) -> Result<
        models::CreateMultipleDepositAddressesJobStatus,
        Error<GetCreateMultipleDepositAddressesJobStatusError>,
    > {
        let GetCreateMultipleDepositAddressesJobStatusParams { job_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/addresses/bulk/{jobId}",
            local_var_configuration.base_path,
            jobId = crate::apis::urlencode(job_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::CreateMultipleDepositAddressesJobStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::CreateMultipleDepositAddressesJobStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetCreateMultipleDepositAddressesJobStatusError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get the maximum amount of a particular asset that can be spent in a
    /// single transaction from a specified vault account (UTXO assets only).
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_max_spendable_amount(
        &self,
        params: GetMaxSpendableAmountParams,
    ) -> Result<models::GetMaxSpendableAmountResponse, Error<GetMaxSpendableAmountError>> {
        let GetMaxSpendableAmountParams {
            vault_account_id,
            asset_id,
            manual_signging,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = manual_signging {
            local_var_req_builder =
                local_var_req_builder.query(&[("manualSignging", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::GetMaxSpendableAmountResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::GetMaxSpendableAmountResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetMaxSpendableAmountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets all vault accounts in your workspace. This endpoint returns a
    /// limited amount of results with a quick response time. </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_paged_vault_accounts(
        &self,
        params: GetPagedVaultAccountsParams,
    ) -> Result<models::VaultAccountsPagedResponse, Error<GetPagedVaultAccountsError>> {
        let GetPagedVaultAccountsParams {
            name_prefix,
            name_suffix,
            min_amount_threshold,
            asset_id,
            order_by,
            before,
            after,
            limit,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str =
            format!("{}/vault/accounts_paged", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = name_prefix {
            local_var_req_builder =
                local_var_req_builder.query(&[("namePrefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = name_suffix {
            local_var_req_builder =
                local_var_req_builder.query(&[("nameSuffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = min_amount_threshold {
            local_var_req_builder =
                local_var_req_builder.query(&[("minAmountThreshold", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = asset_id {
            local_var_req_builder =
                local_var_req_builder.query(&[("assetId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = order_by {
            local_var_req_builder =
                local_var_req_builder.query(&[("orderBy", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = before {
            local_var_req_builder =
                local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder =
                local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = limit {
            local_var_req_builder =
                local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultAccountsPagedResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultAccountsPagedResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetPagedVaultAccountsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets the public key information based on derivation path and signing
    /// algorithm. </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn get_public_key_info(
        &self,
        params: GetPublicKeyInfoParams,
    ) -> Result<models::PublicKeyInformation, Error<GetPublicKeyInfoError>> {
        let GetPublicKeyInfoParams {
            derivation_path,
            algorithm,
            compressed,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/public_key_info",
            local_var_configuration.base_path
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &derivation_path
                    .into_iter()
                    .map(|p| ("derivationPath".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "derivationPath",
                &derivation_path
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
        local_var_req_builder =
            local_var_req_builder.query(&[("algorithm", &algorithm.to_string())]);
        if let Some(ref local_var_str) = compressed {
            local_var_req_builder =
                local_var_req_builder.query(&[("compressed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::PublicKeyInformation`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::PublicKeyInformation`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetPublicKeyInfoError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get the public key information for a specific asset in a vault account.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn get_public_key_info_for_address(
        &self,
        params: GetPublicKeyInfoForAddressParams,
    ) -> Result<models::PublicKeyInformation, Error<GetPublicKeyInfoForAddressError>> {
        let GetPublicKeyInfoForAddressParams {
            vault_account_id,
            asset_id,
            change,
            address_index,
            compressed,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id),
            change = change,
            addressIndex = address_index
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = compressed {
            local_var_req_builder =
                local_var_req_builder.query(&[("compressed", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::PublicKeyInformation`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::PublicKeyInformation`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetPublicKeyInfoForAddressError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns unspent inputs information of an UTXO asset in a vault account.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_unspent_inputs(
        &self,
        params: GetUnspentInputsParams,
    ) -> Result<Vec<models::UnspentInputsResponse>, Error<GetUnspentInputsError>> {
        let GetUnspentInputsParams {
            vault_account_id,
            asset_id,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `Vec&lt;models::UnspentInputsResponse&gt;`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `Vec&lt;models::UnspentInputsResponse&gt;`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetUnspentInputsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get a vault account by its unique ID. </br>Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_vault_account(
        &self,
        params: GetVaultAccountParams,
    ) -> Result<models::VaultAccount, Error<GetVaultAccountError>> {
        let GetVaultAccountParams { vault_account_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultAccount`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultAccount`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetVaultAccountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a specific vault wallet balance information for a specific
    /// asset.  </br>Endpoint Permission: Admin, Non-Signing Admin, Signer,
    /// Approver, Editor,   Viewer.
    async fn get_vault_account_asset(
        &self,
        params: GetVaultAccountAssetParams,
    ) -> Result<models::VaultAsset, Error<GetVaultAccountAssetError>> {
        let GetVaultAccountAssetParams {
            vault_account_id,
            asset_id,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultAsset`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultAsset`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetVaultAccountAssetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// DEPRECATED!  - If your application logic or scripts rely on the
    /// deprecated endpoint, you should update to account for
    /// GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated
    /// before Mar 31,2024. - All workspaces created after Mar 31,2024. will
    /// have it disabled. If it is disabled for your workspace and you attempt
    /// to use it, you will receive the following error message: \"This endpoint
    /// is unavailable. - Please use the GET
    /// /v1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated
    /// endpoint to return all the wallet addresses associated with the
    /// specified vault account and asset in a paginated list.  </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor, Viewer.
    async fn get_vault_account_asset_addresses(
        &self,
        params: GetVaultAccountAssetAddressesParams,
    ) -> Result<Vec<models::VaultWalletAddress>, Error<GetVaultAccountAssetAddressesError>> {
        let GetVaultAccountAssetAddressesParams {
            vault_account_id,
            asset_id,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/addresses",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `Vec&lt;models::VaultWalletAddress&gt;`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `Vec&lt;models::VaultWalletAddress&gt;`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetVaultAccountAssetAddressesError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns a paginated response of the addresses for a given vault account
    /// and asset. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer,
    /// Approver, Editor, Viewer.
    async fn get_vault_account_asset_addresses_paginated(
        &self,
        params: GetVaultAccountAssetAddressesPaginatedParams,
    ) -> Result<models::PaginatedAddressResponse, Error<GetVaultAccountAssetAddressesPaginatedError>>
    {
        let GetVaultAccountAssetAddressesPaginatedParams {
            vault_account_id,
            asset_id,
            limit,
            before,
            after,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = limit {
            local_var_req_builder =
                local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = before {
            local_var_req_builder =
                local_var_req_builder.query(&[("before", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = after {
            local_var_req_builder =
                local_var_req_builder.query(&[("after", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::PaginatedAddressResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::PaginatedAddressResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetVaultAccountAssetAddressesPaginatedError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets the assets amount summary for all accounts or filtered accounts.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_vault_assets(
        &self,
        params: GetVaultAssetsParams,
    ) -> Result<Vec<models::VaultAsset>, Error<GetVaultAssetsError>> {
        let GetVaultAssetsParams {
            account_name_prefix,
            account_name_suffix,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/vault/assets", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = account_name_prefix {
            local_var_req_builder =
                local_var_req_builder.query(&[("accountNamePrefix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = account_name_suffix {
            local_var_req_builder =
                local_var_req_builder.query(&[("accountNameSuffix", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `Vec&lt;models::VaultAsset&gt;`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `Vec&lt;models::VaultAsset&gt;`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetVaultAssetsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Get the total balance of an asset across all the vault accounts.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver,
    /// Editor, Viewer.
    async fn get_vault_balance_by_asset(
        &self,
        params: GetVaultBalanceByAssetParams,
    ) -> Result<models::VaultAsset, Error<GetVaultBalanceByAssetError>> {
        let GetVaultBalanceByAssetParams { asset_id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/assets/{assetId}",
            local_var_configuration.base_path,
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultAsset`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultAsset`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<GetVaultBalanceByAssetError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Hides the requested vault account from the web console view. This operation is required when creating thousands of vault accounts to serve your end-users. Used for preventing the web console to be swamped with too much vault accounts. Learn more in the following [guide](https://developers.fireblocks.com/docs/create-direct-custody-wallets#hiding-vault-accounts). NOTE: Hiding the vault account from the web console will also hide all the related transactions to/from this vault. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn hide_vault_account(
        &self,
        params: HideVaultAccountParams,
    ) -> Result<models::VaultActionStatus, Error<HideVaultAccountError>> {
        let HideVaultAccountParams {
            vault_account_id,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/hide",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultActionStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultActionStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<HideVaultAccountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Sets an AML/KYT customer reference ID for a specific address.
    /// </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn set_customer_ref_id_for_address(
        &self,
        params: SetCustomerRefIdForAddressParams,
    ) -> Result<models::VaultActionStatus, Error<SetCustomerRefIdForAddressError>> {
        let SetCustomerRefIdForAddressParams {
            vault_account_id,
            asset_id,
            address_id,
            set_customer_ref_id_for_address_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/\
             set_customer_ref_id",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id),
            addressId = crate::apis::urlencode(address_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder =
            local_var_req_builder.json(&set_customer_ref_id_for_address_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultActionStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultActionStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<SetCustomerRefIdForAddressError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Toggles the auto fueling property of the vault account to enabled or disabled. Vault Accounts with 'autoFuel=true' are monitored and auto fueled by the Fireblocks Gas Station. Learn more about the Fireblocks Gas Station in the following [guide](https://developers.fireblocks.com/docs/work-with-gas-station). </br>Endpoint Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn set_vault_account_auto_fuel(
        &self,
        params: SetVaultAccountAutoFuelParams,
    ) -> Result<models::VaultActionStatus, Error<SetVaultAccountAutoFuelError>> {
        let SetVaultAccountAutoFuelParams {
            vault_account_id,
            set_auto_fuel_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/set_auto_fuel",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&set_auto_fuel_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultActionStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultActionStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<SetVaultAccountAutoFuelError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Assigns an AML/KYT customer reference ID for the vault account. Learn more about Fireblocks AML management in the following [guide](https://developers.fireblocks.com/docs/define-aml-policies). </br>Endpoint Permission: Admin, Non-Signing Admin.
    async fn set_vault_account_customer_ref_id(
        &self,
        params: SetVaultAccountCustomerRefIdParams,
    ) -> Result<models::VaultActionStatus, Error<SetVaultAccountCustomerRefIdError>> {
        let SetVaultAccountCustomerRefIdParams {
            vault_account_id,
            set_customer_ref_id_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/set_customer_ref_id",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&set_customer_ref_id_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultActionStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultActionStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<SetVaultAccountCustomerRefIdError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Makes a hidden vault account visible in web console view. </br>Endpoint
    /// Permission: Admin, Non-Signing Admin, Signer, Approver, Editor.
    async fn unhide_vault_account(
        &self,
        params: UnhideVaultAccountParams,
    ) -> Result<models::VaultActionStatus, Error<UnhideVaultAccountError>> {
        let UnhideVaultAccountParams {
            vault_account_id,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/unhide",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultActionStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultActionStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<UnhideVaultAccountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Renames the requested vault account. </br>Endpoint Permission: Admin,
    /// Non-Signing Admin, Signer, Approver.
    async fn update_vault_account(
        &self,
        params: UpdateVaultAccountParams,
    ) -> Result<models::RenameVaultAccountResponse, Error<UpdateVaultAccountError>> {
        let UpdateVaultAccountParams {
            vault_account_id,
            update_vault_account_request,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&update_vault_account_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::RenameVaultAccountResponse`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::RenameVaultAccountResponse`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<UpdateVaultAccountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates the description of an existing address of an asset in a vault
    /// account. </br>Endpoint Permission: Admin, Non-Signing Admin, Signer,
    /// Approver, Editor.
    async fn update_vault_account_asset_address(
        &self,
        params: UpdateVaultAccountAssetAddressParams,
    ) -> Result<models::VaultActionStatus, Error<UpdateVaultAccountAssetAddressError>> {
        let UpdateVaultAccountAssetAddressParams {
            vault_account_id,
            asset_id,
            address_id,
            idempotency_key,
            update_vault_account_asset_address_request,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id),
            addressId = crate::apis::urlencode(address_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder =
            local_var_req_builder.json(&update_vault_account_asset_address_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultActionStatus`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultActionStatus`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<UpdateVaultAccountAssetAddressError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates the balance of a specific asset in a vault account.  This API
    /// endpoint is subject to a strict rate limit. Should be used by clients in
    /// very specific scenarios.  </br>Endpoint Permission: Admin, Non-Signing
    /// Admin, Signer, Approver, Editor.
    async fn update_vault_account_asset_balance(
        &self,
        params: UpdateVaultAccountAssetBalanceParams,
    ) -> Result<models::VaultAsset, Error<UpdateVaultAccountAssetBalanceError>> {
        let UpdateVaultAccountAssetBalanceParams {
            vault_account_id,
            asset_id,
            idempotency_key,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/vault/accounts/{vaultAccountId}/{assetId}/balance",
            local_var_configuration.base_path,
            vaultAccountId = crate::apis::urlencode(vault_account_id),
            assetId = crate::apis::urlencode(asset_id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder =
                local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content_type = local_var_resp
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("application/octet-stream");
        let local_var_content_type = super::ContentType::from(local_var_content_type);
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            match local_var_content_type {
                ContentType::Json => serde_json::from_str(&local_var_content).map_err(Error::from),
                ContentType::Text => {
                    return Err(Error::from(serde_json::Error::custom(
                        "Received `text/plain` content type response that cannot be converted to \
                         `models::VaultAsset`",
                    )))
                }
                ContentType::Unsupported(local_var_unknown_type) => {
                    return Err(Error::from(serde_json::Error::custom(format!(
                        "Received `{local_var_unknown_type}` content type response that cannot be \
                         converted to `models::VaultAsset`"
                    ))))
                }
            }
        } else {
            let local_var_entity: Option<UpdateVaultAccountAssetBalanceError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed errors of method [`activate_asset_for_vault_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActivateAssetForVaultAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_legacy_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLegacyAddressError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_multiple_deposit_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMultipleDepositAddressesError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_vault_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVaultAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_vault_account_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVaultAccountAssetError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_vault_account_asset_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVaultAccountAssetAddressError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_wallets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetWalletsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`get_create_multiple_deposit_addresses_job_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCreateMultipleDepositAddressesJobStatusError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_max_spendable_amount`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMaxSpendableAmountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_paged_vault_accounts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPagedVaultAccountsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_public_key_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPublicKeyInfoError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_public_key_info_for_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPublicKeyInfoForAddressError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_unspent_inputs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUnspentInputsError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vault_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaultAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vault_account_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaultAccountAssetError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vault_account_asset_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaultAccountAssetAddressesError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`get_vault_account_asset_addresses_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaultAccountAssetAddressesPaginatedError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vault_assets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaultAssetsError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_vault_balance_by_asset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVaultBalanceByAssetError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hide_vault_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HideVaultAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_customer_ref_id_for_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCustomerRefIdForAddressError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_vault_account_auto_fuel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetVaultAccountAutoFuelError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_vault_account_customer_ref_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetVaultAccountCustomerRefIdError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unhide_vault_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnhideVaultAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_vault_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVaultAccountError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_vault_account_asset_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVaultAccountAssetAddressError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_vault_account_asset_balance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateVaultAccountAssetBalanceError {
    DefaultResponse(models::ErrorSchema),
    UnknownValue(serde_json::Value),
}
