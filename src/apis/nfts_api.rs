/*
 * Fireblocks API
 *
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.8.0
 * Contact: developers@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait NftsApi: Send + Sync {
    async fn get_nft(&self,  params: GetNftParams ) -> Result<models::TokenResponse, Error<GetNftError>>;
    async fn get_nfts(&self,  params: GetNftsParams ) -> Result<models::GetNftsResponse, Error<GetNftsError>>;
    async fn get_ownership_tokens(&self,  params: GetOwnershipTokensParams ) -> Result<models::GetOwnershipTokensResponse, Error<GetOwnershipTokensError>>;
    async fn list_owned_collections(&self,  params: ListOwnedCollectionsParams ) -> Result<models::ListOwnedCollectionsResponse, Error<ListOwnedCollectionsError>>;
    async fn list_owned_tokens(&self,  params: ListOwnedTokensParams ) -> Result<models::ListOwnedTokensResponse, Error<ListOwnedTokensError>>;
    async fn refresh_nft_metadata(&self,  params: RefreshNftMetadataParams ) -> Result<(), Error<RefreshNftMetadataError>>;
    async fn update_ownership_tokens(&self,  params: UpdateOwnershipTokensParams ) -> Result<(), Error<UpdateOwnershipTokensError>>;
    async fn update_token_ownership_status(&self,  params: UpdateTokenOwnershipStatusParams ) -> Result<(), Error<UpdateTokenOwnershipStatusError>>;
    async fn update_tokens_ownership_spam(&self,  params: UpdateTokensOwnershipSpamParams ) -> Result<(), Error<UpdateTokensOwnershipSpamError>>;
    async fn update_tokens_ownership_status(&self,  params: UpdateTokensOwnershipStatusParams ) -> Result<(), Error<UpdateTokensOwnershipStatusError>>;
}

pub struct NftsApiClient {
    configuration: Arc<configuration::Configuration>
}

impl NftsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`get_nft`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetNftParams {
    /// NFT ID
    pub id: String
}

/// struct for passing parameters to the method [`get_nfts`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetNftsParams {
    /// A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
    pub ids: String,
    /// Page cursor to fetch
    pub page_cursor: Option<String>,
    /// Items per page (max 100)
    pub page_size: Option<f64>,
    /// Sort by param, it can be one param or a list of params separated by comma
    pub sort: Option<Vec<String>>,
    /// Order direction, it can be `ASC` for ascending or `DESC` for descending
    pub order: Option<String>
}

/// struct for passing parameters to the method [`get_ownership_tokens`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetOwnershipTokensParams {
    /// Blockchain descriptor filter
    pub blockchain_descriptor: Option<String>,
    /// A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType=END_USER_WALLET or ncwId is provided.
    pub vault_account_ids: Option<String>,
    /// Non-Custodial Wallet ID
    pub ncw_id: Option<String>,
    /// A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType=VAULT_ACCOUNT or ncwId is not provided.
    pub ncw_account_ids: Option<String>,
    /// Wallet type, it can be `VAULT_ACCOUNT` or `END_USER_WALLET`
    pub wallet_type: Option<String>,
    /// A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
    pub ids: Option<String>,
    /// A comma separated list of collection IDs. Up to 100 are allowed in a single request.
    pub collection_ids: Option<String>,
    /// Page cursor to fetch
    pub page_cursor: Option<String>,
    /// Items per page (max 100)
    pub page_size: Option<f64>,
    /// Sort by param, it can be one param or a list of params separated by comma
    pub sort: Option<Vec<String>>,
    /// Order direction, it can be `ASC` for ascending or `DESC` for descending
    pub order: Option<String>,
    /// Token ownership status
    pub status: Option<String>,
    /// Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name.
    pub search: Option<String>,
    /// Token ownership spam status.
    pub spam: Option<String>
}

/// struct for passing parameters to the method [`list_owned_collections`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ListOwnedCollectionsParams {
    /// Non-Custodial Wallet ID
    pub ncw_id: Option<String>,
    /// Wallet type, it can be `VAULT_ACCOUNT` or `END_USER_WALLET`
    pub wallet_type: Option<String>,
    /// Search owned collections. Possible criteria for search: collection name, collection contract address.
    pub search: Option<String>,
    /// Page cursor to fetch
    pub page_cursor: Option<String>,
    /// Items per page (max 100)
    pub page_size: Option<f64>,
    /// Sort by param, it can be one param or a list of params separated by comma
    pub sort: Option<Vec<String>>,
    /// Order direction, it can be `ASC` for ascending or `DESC` for descending
    pub order: Option<String>,
    /// Token ownership status
    pub status: Option<String>
}

/// struct for passing parameters to the method [`list_owned_tokens`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ListOwnedTokensParams {
    /// Non-Custodial Wallet ID
    pub ncw_id: Option<String>,
    /// Wallet type, it can be `VAULT_ACCOUNT` or `END_USER_WALLET`
    pub wallet_type: Option<String>,
    /// Page cursor to fetch
    pub page_cursor: Option<String>,
    /// Items per page (max 100)
    pub page_size: Option<f64>,
    /// Sort by param, it can be one param or a list of params separated by comma
    pub sort: Option<Vec<String>>,
    /// Order direction, it can be `ASC` for ascending or `DESC` for descending
    pub order: Option<String>,
    /// Token ownership status
    pub status: Option<String>,
    /// Search owned tokens by token name
    pub search: Option<String>,
    /// Token ownership spam status.
    pub spam: Option<String>
}

/// struct for passing parameters to the method [`refresh_nft_metadata`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct RefreshNftMetadataParams {
    /// NFT ID
    pub id: String,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`update_ownership_tokens`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateOwnershipTokensParams {
    /// Blockchain descriptor filter
    pub blockchain_descriptor: String,
    /// Vault account filter
    pub vault_account_id: String,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`update_token_ownership_status`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateTokenOwnershipStatusParams {
    /// NFT ID
    pub id: String,
    pub update_token_ownership_status_dto: models::UpdateTokenOwnershipStatusDto,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`update_tokens_ownership_spam`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateTokensOwnershipSpamParams {
    pub token_ownership_spam_update_payload: Vec<models::TokenOwnershipSpamUpdatePayload>,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`update_tokens_ownership_status`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateTokensOwnershipStatusParams {
    pub token_ownership_status_update_payload: Vec<models::TokenOwnershipStatusUpdatePayload>,
    /// A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
    pub idempotency_key: Option<String>
}


#[async_trait]
impl NftsApi for NftsApiClient {
    /// Returns the requested token data. 
    async fn get_nft(&self,  params: GetNftParams ) -> Result<models::TokenResponse, Error<GetNftError>> {
        
        let GetNftParams {
            id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/tokens/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetNftError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns the requested tokens data. 
    async fn get_nfts(&self,  params: GetNftsParams ) -> Result<models::GetNftsResponse, Error<GetNftsError>> {
        
        let GetNftsParams {
            ids,
            page_cursor,
            page_size,
            sort,
            order,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/tokens", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        local_var_req_builder = local_var_req_builder.query(&[("ids", &ids.to_string())]);
        if let Some(ref local_var_str) = page_cursor {
            local_var_req_builder = local_var_req_builder.query(&[("pageCursor", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("sort", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref local_var_str) = order {
            local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetNftsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all tokens and their data in your workspace. 
    async fn get_ownership_tokens(&self,  params: GetOwnershipTokensParams ) -> Result<models::GetOwnershipTokensResponse, Error<GetOwnershipTokensError>> {
        
        let GetOwnershipTokensParams {
            blockchain_descriptor,
            vault_account_ids,
            ncw_id,
            ncw_account_ids,
            wallet_type,
            ids,
            collection_ids,
            page_cursor,
            page_size,
            sort,
            order,
            status,
            search,
            spam,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/tokens", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = blockchain_descriptor {
            local_var_req_builder = local_var_req_builder.query(&[("blockchainDescriptor", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = vault_account_ids {
            local_var_req_builder = local_var_req_builder.query(&[("vaultAccountIds", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ncw_id {
            local_var_req_builder = local_var_req_builder.query(&[("ncwId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ncw_account_ids {
            local_var_req_builder = local_var_req_builder.query(&[("ncwAccountIds", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wallet_type {
            local_var_req_builder = local_var_req_builder.query(&[("walletType", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = ids {
            local_var_req_builder = local_var_req_builder.query(&[("ids", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = collection_ids {
            local_var_req_builder = local_var_req_builder.query(&[("collectionIds", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_cursor {
            local_var_req_builder = local_var_req_builder.query(&[("pageCursor", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("sort", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref local_var_str) = order {
            local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = status {
            local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search {
            local_var_req_builder = local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = spam {
            local_var_req_builder = local_var_req_builder.query(&[("spam", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetOwnershipTokensError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all collections in your workspace 
    async fn list_owned_collections(&self,  params: ListOwnedCollectionsParams ) -> Result<models::ListOwnedCollectionsResponse, Error<ListOwnedCollectionsError>> {
        
        let ListOwnedCollectionsParams {
            ncw_id,
            wallet_type,
            search,
            page_cursor,
            page_size,
            sort,
            order,
            status,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/collections", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = ncw_id {
            local_var_req_builder = local_var_req_builder.query(&[("ncwId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wallet_type {
            local_var_req_builder = local_var_req_builder.query(&[("walletType", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search {
            local_var_req_builder = local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_cursor {
            local_var_req_builder = local_var_req_builder.query(&[("pageCursor", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("sort", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref local_var_str) = order {
            local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = status {
            local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<ListOwnedCollectionsError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all owned distinct tokens (for your workspace) and their data in your workspace. 
    async fn list_owned_tokens(&self,  params: ListOwnedTokensParams ) -> Result<models::ListOwnedTokensResponse, Error<ListOwnedTokensError>> {
        
        let ListOwnedTokensParams {
            ncw_id,
            wallet_type,
            page_cursor,
            page_size,
            sort,
            order,
            status,
            search,
            spam,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/assets", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = ncw_id {
            local_var_req_builder = local_var_req_builder.query(&[("ncwId", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = wallet_type {
            local_var_req_builder = local_var_req_builder.query(&[("walletType", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_cursor {
            local_var_req_builder = local_var_req_builder.query(&[("pageCursor", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = sort {
            local_var_req_builder = match "multi" {
                "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("sort".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
                _ => local_var_req_builder.query(&[("sort", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
            };
        }
        if let Some(ref local_var_str) = order {
            local_var_req_builder = local_var_req_builder.query(&[("order", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = status {
            local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = search {
            local_var_req_builder = local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = spam {
            local_var_req_builder = local_var_req_builder.query(&[("spam", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<ListOwnedTokensError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates the latest token metadata. 
    async fn refresh_nft_metadata(&self,  params: RefreshNftMetadataParams ) -> Result<(), Error<RefreshNftMetadataError>> {
        
        let RefreshNftMetadataParams {
            id,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/tokens/{id}", local_var_configuration.base_path, id=crate::apis::urlencode(id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<RefreshNftMetadataError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates all tokens and balances per blockchain and vault account. 
    async fn update_ownership_tokens(&self,  params: UpdateOwnershipTokensParams ) -> Result<(), Error<UpdateOwnershipTokensError>> {
        
        let UpdateOwnershipTokensParams {
            blockchain_descriptor,
            vault_account_id,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/tokens", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        local_var_req_builder = local_var_req_builder.query(&[("blockchainDescriptor", &blockchain_descriptor.to_string())]);
        local_var_req_builder = local_var_req_builder.query(&[("vaultAccountId", &vault_account_id.to_string())]);
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<UpdateOwnershipTokensError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates token status for a workspace, in all workspace vaults. 
    async fn update_token_ownership_status(&self,  params: UpdateTokenOwnershipStatusParams ) -> Result<(), Error<UpdateTokenOwnershipStatusError>> {
        
        let UpdateTokenOwnershipStatusParams {
            id,
            update_token_ownership_status_dto,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/tokens/{id}/status", local_var_configuration.base_path, id=crate::apis::urlencode(id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&update_token_ownership_status_dto);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<UpdateTokenOwnershipStatusError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates tokens spam property for a workspace's token ownerships, in all vault accounts.
    async fn update_tokens_ownership_spam(&self,  params: UpdateTokensOwnershipSpamParams ) -> Result<(), Error<UpdateTokensOwnershipSpamError>> {
        
        let UpdateTokensOwnershipSpamParams {
            token_ownership_spam_update_payload,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/tokens/spam", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&token_ownership_spam_update_payload);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<UpdateTokensOwnershipSpamError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates tokens status for a workspace, in all vault accounts.
    async fn update_tokens_ownership_status(&self,  params: UpdateTokensOwnershipStatusParams ) -> Result<(), Error<UpdateTokensOwnershipStatusError>> {
        
        let UpdateTokensOwnershipStatusParams {
            token_ownership_status_update_payload,
            idempotency_key,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/nfts/ownership/tokens/status", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(local_var_param_value) = idempotency_key {
            local_var_req_builder = local_var_req_builder.header("Idempotency-Key", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.json(&token_ownership_status_update_payload);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            Ok(())
        } else {
            let local_var_entity: Option<UpdateTokensOwnershipStatusError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`get_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nfts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ownership_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOwnershipTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_owned_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOwnedCollectionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_owned_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOwnedTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`refresh_nft_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefreshNftMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_ownership_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOwnershipTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_token_ownership_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTokenOwnershipStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tokens_ownership_spam`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTokensOwnershipSpamError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_tokens_ownership_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTokensOwnershipStatusError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

