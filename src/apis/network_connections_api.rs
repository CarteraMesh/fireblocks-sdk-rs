/*
 * Fireblocks API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.7.5
 * Contact: support@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait NetworkConnectionsApi: Send + Sync {
    async fn network_connections_connection_id_delete(&self,  params: NetworkConnectionsConnectionIdDeleteParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkConnectionsConnectionIdDeleteError>>;
    async fn network_connections_connection_id_get(&self,  params: NetworkConnectionsConnectionIdGetParams ) -> Result<models::NetworkConnectionResponse, Error<NetworkConnectionsConnectionIdGetError>>;
    async fn network_connections_connection_id_is_third_party_routing_asset_type_get(&self,  params: NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetParams ) -> Result<models::NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGet200Response, Error<NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetError>>;
    async fn network_connections_connection_id_set_routing_policy_patch(&self,  params: NetworkConnectionsConnectionIdSetRoutingPolicyPatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkConnectionsConnectionIdSetRoutingPolicyPatchError>>;
    async fn network_connections_get(&self, ) -> Result<Vec<models::NetworkConnectionResponse>, Error<NetworkConnectionsGetError>>;
    async fn network_connections_post(&self,  params: NetworkConnectionsPostParams ) -> Result<models::NetworkConnectionResponse, Error<NetworkConnectionsPostError>>;
    async fn network_ids_get(&self, ) -> Result<Vec<models::NetworkIdResponse>, Error<NetworkIdsGetError>>;
    async fn network_ids_network_id_delete(&self,  params: NetworkIdsNetworkIdDeleteParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdDeleteError>>;
    async fn network_ids_network_id_get(&self,  params: NetworkIdsNetworkIdGetParams ) -> Result<models::NetworkIdResponse, Error<NetworkIdsNetworkIdGetError>>;
    async fn network_ids_network_id_set_discoverability_patch(&self,  params: NetworkIdsNetworkIdSetDiscoverabilityPatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdSetDiscoverabilityPatchError>>;
    async fn network_ids_network_id_set_name_patch(&self,  params: NetworkIdsNetworkIdSetNamePatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdSetNamePatchError>>;
    async fn network_ids_network_id_set_routing_policy_patch(&self,  params: NetworkIdsNetworkIdSetRoutingPolicyPatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdSetRoutingPolicyPatchError>>;
    async fn network_ids_post(&self,  params: NetworkIdsPostParams ) -> Result<models::NetworkIdResponse, Error<NetworkIdsPostError>>;
}

pub struct NetworkConnectionsApiClient {
    configuration: Arc<configuration::Configuration>
}

impl NetworkConnectionsApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`network_connections_connection_id_delete`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkConnectionsConnectionIdDeleteParams {
    /// The ID of the network connection to delete
    pub connection_id: String
}

/// struct for passing parameters to the method [`network_connections_connection_id_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkConnectionsConnectionIdGetParams {
    /// The ID of the connection
    pub connection_id: String
}

/// struct for passing parameters to the method [`network_connections_connection_id_is_third_party_routing_asset_type_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetParams {
    /// The ID of the network connection
    pub connection_id: String,
    /// The destination asset type
    pub asset_type: String
}

/// struct for passing parameters to the method [`network_connections_connection_id_set_routing_policy_patch`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkConnectionsConnectionIdSetRoutingPolicyPatchParams {
    /// The ID of the network connection
    pub connection_id: String,
    pub network_connections_connection_id_set_routing_policy_patch_request: Option<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatchRequest>
}

/// struct for passing parameters to the method [`network_connections_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkConnectionsPostParams {
    pub network_connection: Option<models::NetworkConnection>
}

/// struct for passing parameters to the method [`network_ids_network_id_delete`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkIdsNetworkIdDeleteParams {
    /// The ID of the network
    pub network_id: String
}

/// struct for passing parameters to the method [`network_ids_network_id_get`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkIdsNetworkIdGetParams {
    /// The ID of the network
    pub network_id: String
}

/// struct for passing parameters to the method [`network_ids_network_id_set_discoverability_patch`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkIdsNetworkIdSetDiscoverabilityPatchParams {
    /// The ID of the network
    pub network_id: String,
    pub network_ids_network_id_set_discoverability_patch_request: models::NetworkIdsNetworkIdSetDiscoverabilityPatchRequest
}

/// struct for passing parameters to the method [`network_ids_network_id_set_name_patch`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkIdsNetworkIdSetNamePatchParams {
    /// The ID of the network
    pub network_id: String,
    pub network_ids_network_id_set_name_patch_request: models::NetworkIdsNetworkIdSetNamePatchRequest
}

/// struct for passing parameters to the method [`network_ids_network_id_set_routing_policy_patch`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkIdsNetworkIdSetRoutingPolicyPatchParams {
    /// The ID of the network
    pub network_id: String,
    pub network_ids_network_id_set_routing_policy_patch_request: Option<models::NetworkIdsNetworkIdSetRoutingPolicyPatchRequest>
}

/// struct for passing parameters to the method [`network_ids_post`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct NetworkIdsPostParams {
    pub network_ids_post_request: Option<models::NetworkIdsPostRequest>
}


#[async_trait]
impl NetworkConnectionsApi for NetworkConnectionsApiClient {
    /// Deletes an existing network connection specified by its connection ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_connections_connection_id_delete(&self,  params: NetworkConnectionsConnectionIdDeleteParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkConnectionsConnectionIdDeleteError>> {
        
        let NetworkConnectionsConnectionIdDeleteParams {
            connection_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_connections/{connectionId}", local_var_configuration.base_path, connectionId=crate::apis::urlencode(connection_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkConnectionsConnectionIdDeleteError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Gets a network connection by ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_connections_connection_id_get(&self,  params: NetworkConnectionsConnectionIdGetParams ) -> Result<models::NetworkConnectionResponse, Error<NetworkConnectionsConnectionIdGetError>> {
        
        let NetworkConnectionsConnectionIdGetParams {
            connection_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_connections/{connectionId}", local_var_configuration.base_path, connectionId=crate::apis::urlencode(connection_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkConnectionsConnectionIdGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// The Fireblocks Network allows for flexibility around incoming deposits. A receiver can receive network deposits to locations other than Fireblocks. This endpoint validates whether future transactions are routed to the displayed recipient or to a 3rd party.
    async fn network_connections_connection_id_is_third_party_routing_asset_type_get(&self,  params: NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetParams ) -> Result<models::NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGet200Response, Error<NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetError>> {
        
        let NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetParams {
            connection_id,
            asset_type,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_connections/{connectionId}/is_third_party_routing/{assetType}", local_var_configuration.base_path, connectionId=crate::apis::urlencode(connection_id), assetType=crate::apis::urlencode(asset_type));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates an existing network connection's routing policy.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_connections_connection_id_set_routing_policy_patch(&self,  params: NetworkConnectionsConnectionIdSetRoutingPolicyPatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkConnectionsConnectionIdSetRoutingPolicyPatchError>> {
        
        let NetworkConnectionsConnectionIdSetRoutingPolicyPatchParams {
            connection_id,
            network_connections_connection_id_set_routing_policy_patch_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_connections/{connectionId}/set_routing_policy", local_var_configuration.base_path, connectionId=crate::apis::urlencode(connection_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&network_connections_connection_id_set_routing_policy_patch_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkConnectionsConnectionIdSetRoutingPolicyPatchError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Returns all network connections.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_connections_get(&self, ) -> Result<Vec<models::NetworkConnectionResponse>, Error<NetworkConnectionsGetError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_connections", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkConnectionsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Initiates a new network connection.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_connections_post(&self,  params: NetworkConnectionsPostParams ) -> Result<models::NetworkConnectionResponse, Error<NetworkConnectionsPostError>> {
        
        let NetworkConnectionsPostParams {
            network_connection,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_connections", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&network_connection);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkConnectionsPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Retrieves a list of all local and discoverable remote network IDs.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_get(&self, ) -> Result<Vec<models::NetworkIdResponse>, Error<NetworkIdsGetError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Deletes a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_network_id_delete(&self,  params: NetworkIdsNetworkIdDeleteParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdDeleteError>> {
        
        let NetworkIdsNetworkIdDeleteParams {
            network_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids/{networkId}", local_var_configuration.base_path, networkId=crate::apis::urlencode(network_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsNetworkIdDeleteError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Retrieves a network by its ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_network_id_get(&self,  params: NetworkIdsNetworkIdGetParams ) -> Result<models::NetworkIdResponse, Error<NetworkIdsNetworkIdGetError>> {
        
        let NetworkIdsNetworkIdGetParams {
            network_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids/{networkId}", local_var_configuration.base_path, networkId=crate::apis::urlencode(network_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsNetworkIdGetError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Update whether or not the network ID is discoverable by others.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_network_id_set_discoverability_patch(&self,  params: NetworkIdsNetworkIdSetDiscoverabilityPatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdSetDiscoverabilityPatchError>> {
        
        let NetworkIdsNetworkIdSetDiscoverabilityPatchParams {
            network_id,
            network_ids_network_id_set_discoverability_patch_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids/{networkId}/set_discoverability", local_var_configuration.base_path, networkId=crate::apis::urlencode(network_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&network_ids_network_id_set_discoverability_patch_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsNetworkIdSetDiscoverabilityPatchError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates name of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_network_id_set_name_patch(&self,  params: NetworkIdsNetworkIdSetNamePatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdSetNamePatchError>> {
        
        let NetworkIdsNetworkIdSetNamePatchParams {
            network_id,
            network_ids_network_id_set_name_patch_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids/{networkId}/set_name", local_var_configuration.base_path, networkId=crate::apis::urlencode(network_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&network_ids_network_id_set_name_patch_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsNetworkIdSetNamePatchError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Updates the routing policy of a specified network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_network_id_set_routing_policy_patch(&self,  params: NetworkIdsNetworkIdSetRoutingPolicyPatchParams ) -> Result<models::NetworkConnectionsConnectionIdSetRoutingPolicyPatch200Response, Error<NetworkIdsNetworkIdSetRoutingPolicyPatchError>> {
        
        let NetworkIdsNetworkIdSetRoutingPolicyPatchParams {
            network_id,
            network_ids_network_id_set_routing_policy_patch_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids/{networkId}/set_routing_policy", local_var_configuration.base_path, networkId=crate::apis::urlencode(network_id));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&network_ids_network_id_set_routing_policy_patch_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsNetworkIdSetRoutingPolicyPatchError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Creates a new Network ID.  **Note:** This API call is subject to Flexible Routing Schemes.  Your routing policy defines how your transactions are routed. You can choose 1 of the 3 different schemes mentioned below for each asset type:   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as \"Profile Routing\"  Default Workspace Presets:   - Network Profile Crypto → **Custom**   - Network Profile FIAT → **None**   - Network Connection Crypto → **Default**   - Network Connection FIAT → **Default**      - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`). 
    async fn network_ids_post(&self,  params: NetworkIdsPostParams ) -> Result<models::NetworkIdResponse, Error<NetworkIdsPostError>> {
        
        let NetworkIdsPostParams {
            network_ids_post_request,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/network_ids", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        local_var_req_builder = local_var_req_builder.json(&network_ids_post_request);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<NetworkIdsPostError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`network_connections_connection_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkConnectionsConnectionIdDeleteError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_connections_connection_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkConnectionsConnectionIdGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_connections_connection_id_is_third_party_routing_asset_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkConnectionsConnectionIdIsThirdPartyRoutingAssetTypeGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_connections_connection_id_set_routing_policy_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkConnectionsConnectionIdSetRoutingPolicyPatchError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_connections_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkConnectionsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_connections_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkConnectionsPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_network_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsNetworkIdDeleteError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_network_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsNetworkIdGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_network_id_set_discoverability_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsNetworkIdSetDiscoverabilityPatchError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_network_id_set_name_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsNetworkIdSetNamePatchError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_network_id_set_routing_policy_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsNetworkIdSetRoutingPolicyPatchError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`network_ids_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NetworkIdsPostError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

