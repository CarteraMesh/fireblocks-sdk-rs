/*
 * Fireblocks API
 *
 * Fireblocks provides a suite of applications to manage digital asset operations and a complete development platform to build your business on the blockchain.  - Visit our website for more information: [Fireblocks Website](https://fireblocks.com) - Visit our developer docs: [Fireblocks DevPortal](https://developers.fireblocks.com) 
 *
 * The version of the OpenAPI document: 1.8.0
 * Contact: developers@fireblocks.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransactionRequest {
    #[serde(rename = "operation", skip_serializing_if = "Option::is_none")]
    pub operation: Option<models::TransactionOperation>,
    /// Custom note, not sent to the blockchain, to describe the transaction at your Fireblocks workspace.
    #[serde(rename = "note", skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
    /// An optional but highly recommended parameter. Fireblocks will reject future transactions with same ID.  You should set this to a unique ID representing the transaction, to avoid submitting the same transaction twice. This helps with cases where submitting the transaction responds with an error code due to Internet interruptions, but the transaction was actually sent and processed. To validate whether a transaction has been processed, [Find a specific transaction by external transaction ID](https://developers.fireblocks.com/reference/gettransactionbyexternalid). There is no specific format required for this parameter.
    #[serde(rename = "externalTxId", skip_serializing_if = "Option::is_none")]
    pub external_tx_id: Option<String>,
    /// The ID of the asset to transfer, for `TRANSFER`, `MINT` or `BURN` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/getsupportedassets-1)
    #[serde(rename = "assetId", skip_serializing_if = "Option::is_none")]
    pub asset_id: Option<String>,
    #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
    pub source: Option<models::SourceTransferPeerPath>,
    #[serde(rename = "destination", skip_serializing_if = "Option::is_none")]
    pub destination: Option<models::DestinationTransferPeerPath>,
    /// For UTXO based blockchains, you can send a single transaction to multiple destinations.
    #[serde(rename = "destinations", skip_serializing_if = "Option::is_none")]
    pub destinations: Option<Vec<models::TransactionRequestDestination>>,
    #[serde(rename = "amount", skip_serializing_if = "Option::is_none")]
    pub amount: Option<models::TransactionRequestAmount>,
    /// \"When set to `true`, the fee will be deducted from the requested amount.\"  **Note**: This parameter can only be considered if a transaction’s asset is a base asset, such as ETH or MATIC. If the asset can’t be used for transaction fees, like USDC, this parameter is ignored and the fee is deducted from the relevant base asset wallet in the source account.
    #[serde(rename = "treatAsGrossAmount", skip_serializing_if = "Option::is_none")]
    pub treat_as_gross_amount: Option<bool>,
    /// For Polkadot, Kusama and Westend transactions only. When set to true, Fireblocks will empty the asset wallet.     **Note:** If set to true when the source account is exactly 1 DOT, the transaction will fail. Any amount more or less than 1 DOT succeeds. This is a Polkadot blockchain limitation.
    #[serde(rename = "forceSweep", skip_serializing_if = "Option::is_none")]
    pub force_sweep: Option<bool>,
    /// For UTXO or EVM-based blockchains only. Defines the blockchain fee level which will be payed for the transaction. Alternatively, specific fee estimation parameters exist below.
    #[serde(rename = "feeLevel", skip_serializing_if = "Option::is_none")]
    pub fee_level: Option<FeeLevel>,
    #[serde(rename = "fee", skip_serializing_if = "Option::is_none")]
    pub fee: Option<models::TransactionRequestFee>,
    #[serde(rename = "priorityFee", skip_serializing_if = "Option::is_none")]
    pub priority_fee: Option<models::TransactionRequestPriorityFee>,
    /// When set to `true`, in case the current `MEDIUM` fee level is higher than the one specified in the transaction, the transaction will fail to avoid getting stuck with no confirmations.
    #[serde(rename = "failOnLowFee", skip_serializing_if = "Option::is_none")]
    pub fail_on_low_fee: Option<bool>,
    /// The maximum fee (gas price or fee per byte) that should be payed for the transaction.  In case the current value of the requested `feeLevel` is higher than this requested maximum fee.  Represented by a numeric string for accurate precision.
    #[serde(rename = "maxFee", skip_serializing_if = "Option::is_none")]
    pub max_fee: Option<String>,
    #[serde(rename = "gasLimit", skip_serializing_if = "Option::is_none")]
    pub gas_limit: Option<models::TransactionRequestGasLimit>,
    #[serde(rename = "gasPrice", skip_serializing_if = "Option::is_none")]
    pub gas_price: Option<models::TransactionRequestGasPrice>,
    #[serde(rename = "networkFee", skip_serializing_if = "Option::is_none")]
    pub network_fee: Option<models::TransactionRequestNetworkFee>,
    /// For EVM-based blockchains only. In case a transaction is stuck, specify the hash of the stuck transaction to replace it by this transaction with a higher fee, or to replace it with this transaction with a zero fee and drop it from the blockchain.
    #[serde(rename = "replaceTxByHash", skip_serializing_if = "Option::is_none")]
    pub replace_tx_by_hash: Option<String>,
    #[serde(rename = "extraParameters", skip_serializing_if = "Option::is_none")]
    pub extra_parameters: Option<models::ExtraParameters>,
    /// The ID for AML providers to associate the owner of funds with transactions.
    #[serde(rename = "customerRefId", skip_serializing_if = "Option::is_none")]
    pub customer_ref_id: Option<String>,
    #[serde(rename = "travelRuleMessage", skip_serializing_if = "Option::is_none")]
    pub travel_rule_message: Option<models::TravelRuleCreateTransactionRequest>,
    /// This feature is no longer supported.
    #[serde(rename = "autoStaking", skip_serializing_if = "Option::is_none")]
    pub auto_staking: Option<bool>,
    #[serde(rename = "networkStaking", skip_serializing_if = "Option::is_none")]
    pub network_staking: Option<models::TransactionRequestNetworkStaking>,
    #[serde(rename = "cpuStaking", skip_serializing_if = "Option::is_none")]
    pub cpu_staking: Option<models::TransactionRequestNetworkStaking>,
    /// - Override the default gasless configuration by sending true\\false
    #[serde(rename = "useGasless", skip_serializing_if = "Option::is_none")]
    pub use_gasless: Option<bool>,
}

impl TransactionRequest {
    pub fn new() -> TransactionRequest {
        TransactionRequest {
            operation: None,
            note: None,
            external_tx_id: None,
            asset_id: None,
            source: None,
            destination: None,
            destinations: None,
            amount: None,
            treat_as_gross_amount: None,
            force_sweep: None,
            fee_level: None,
            fee: None,
            priority_fee: None,
            fail_on_low_fee: None,
            max_fee: None,
            gas_limit: None,
            gas_price: None,
            network_fee: None,
            replace_tx_by_hash: None,
            extra_parameters: None,
            customer_ref_id: None,
            travel_rule_message: None,
            auto_staking: None,
            network_staking: None,
            cpu_staking: None,
            use_gasless: None,
        }
    }
}
/// For UTXO or EVM-based blockchains only. Defines the blockchain fee level which will be payed for the transaction. Alternatively, specific fee estimation parameters exist below.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum FeeLevel {
    #[serde(rename = "LOW")]
    Low,
    #[serde(rename = "MEDIUM")]
    Medium,
    #[serde(rename = "HIGH")]
    High,
}

impl Default for FeeLevel {
    fn default() -> FeeLevel {
        Self::Low
    }
}

